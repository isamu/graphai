{"version":3,"file":"bundle.cjs.js","sources":["../src/type.ts","../src/utils/GraphAILogger.ts","../src/utils/prop_function.ts","../src/utils/utils.ts","../src/utils/nodeUtils.ts","../src/transaction_log.ts","../src/utils/data_source.ts","../src/utils/result.ts","../src/node.ts","../src/validators/common.ts","../src/validators/graph_data_validator.ts","../src/validator.ts","../src/validators/nodeValidator.ts","../src/validators/static_node_validator.ts","../src/validators/computed_node_validator.ts","../src/validators/agent_validator.ts","../src/validators/relation_validator.ts","../src/task_manager.ts","../src/graphai.ts"],"sourcesContent":["import type { TransactionLog } from \"./transaction_log\";\nimport type { TaskManager } from \"./task_manager\";\nimport type { GraphAI } from \"./graphai\";\n\nexport enum NodeState {\n  Waiting = \"waiting\",\n  Queued = \"queued\",\n  Executing = \"executing\",\n  ExecutingServer = \"executing-server\",\n  Failed = \"failed\",\n  TimedOut = \"timed-out\",\n  Abort = \"abort\",\n  Completed = \"completed\",\n  Injected = \"injected\",\n  Skipped = \"skipped\",\n}\n\nexport type DefaultResultData = Record<string, any> | string | number | boolean | Array<DefaultResultData>;\nexport type DefaultInputData = Record<string, any>;\nexport type DefaultConfigData = Record<string, any>;\nexport type ResultData<ResultType = DefaultResultData> = ResultType | undefined;\nexport type ResultDataDictionary<ResultType = DefaultResultData> = Record<string, ResultData<ResultType>>;\n\nexport type ConfigData<ConfigType = DefaultConfigData> = ConfigType;\nexport type ConfigDataDictionary<ConfigType = DefaultConfigData> = Record<string, ConfigType>;\nexport type DefaultParamsType = Record<string, any>;\nexport type NodeDataParams<ParamsType = DefaultParamsType> = ParamsType; // Agent-specific parameters\n\nexport type PassThrough = Record<string, any>;\n\nexport type DataSource = {\n  nodeId?: string;\n  value?: any;\n  propIds?: string[];\n};\n\ntype ConsoleAttribute = boolean | string | Record<string, any>;\nexport type ConsoleElement = boolean | { before?: ConsoleAttribute; after?: ConsoleAttribute };\n\nexport type StaticNodeData = {\n  value?: ResultData; // initial value for static node.\n  update?: string; // nodeId (+.propId) to get value after a loop\n  isResult?: boolean;\n  console?: ConsoleElement;\n};\nexport type AgentAnonymousFunction = (...params: any[]) => unknown;\n\nexport type AgentFilterParams = Record<string, any>;\n\nexport type GraphDataLoaderOption = { fileName: string; option?: any };\n\nexport type RepeatUntil = {\n  exists?: string;\n};\n\nexport type ComputedNodeData = {\n  agent: string | AgentAnonymousFunction;\n  inputs?: Record<string, any>;\n  output?: Record<string, any>;\n  anyInput?: boolean; // any input makes this node ready\n  params?: NodeDataParams;\n  filterParams?: AgentFilterParams; // agent filter\n  retry?: number;\n  repeatUntil?: RepeatUntil;\n  timeout?: number; // msec\n  if?: string; // conditional execution\n  unless?: string; // conditional execution\n  defaultValue?: ResultData;\n  graph?: GraphData | string;\n  graphLoader?: GraphDataLoaderOption;\n  isResult?: boolean;\n  priority?: number; // The default is 0.\n  passThrough?: PassThrough; // data that pass trough to result\n  console?: ConsoleElement;\n};\n\nexport type NodeData = StaticNodeData | ComputedNodeData;\n\nexport type LoopData = {\n  count?: number;\n  while?: string | boolean;\n};\n\nexport type GraphData = {\n  version?: number; // major version, 0.1, 0.2, ...\n  nodes: Record<string, NodeData>;\n  concurrency?: number;\n  loop?: LoopData;\n  verbose?: boolean;\n  retry?: number;\n  metadata?: any; // Stores information about GraphData. GraphAI itself is not used this data.\n};\n\nexport type GraphDataLoader = (loaderOption: GraphDataLoaderOption) => GraphData;\n\nexport type GraphOptions = {\n  agentFilters?: AgentFilterInfo[] | undefined;\n  taskManager?: TaskManager | undefined;\n  bypassAgentIds?: string[] | undefined;\n  config?: ConfigDataDictionary;\n  graphLoader?: GraphDataLoader;\n  forceLoop?: boolean;\n  mapIndex?: number;\n};\n\nexport type CacheTypes = \"pureAgent\" | \"impureAgent\";\n\nexport type AgentFunctionContextDebugInfo = {\n  verbose: boolean;\n  nodeId: string;\n  state: string;\n  subGraphs: Map<string, GraphAI>;\n  retry: number;\n  agentId?: string;\n  version?: number;\n  isResult?: boolean;\n};\n\nexport type AgentFunctionContext<ParamsType = DefaultParamsType, NamedInputDataType = DefaultInputData, ConfigType = DefaultConfigData> = {\n  params: NodeDataParams<ParamsType>;\n  inputSchema?: any;\n  namedInputs: NamedInputDataType;\n  debugInfo: AgentFunctionContextDebugInfo;\n  forNestedGraph?: {\n    graphData?: GraphData; // nested graph\n    agents: AgentFunctionInfoDictionary; // for nested graph\n    graphOptions: GraphOptions;\n    onLogCallback?: (log: TransactionLog, isUpdate: boolean) => void;\n    callbacks?: CallbackFunction[];\n  };\n  cacheType?: CacheTypes;\n  filterParams: AgentFilterParams; // agent filter\n  log?: TransactionLog[];\n  config?: ConfigType;\n};\n\nexport type AgentFunction<\n  ParamsType = DefaultParamsType,\n  ResultType = DefaultResultData,\n  NamedInputDataType = DefaultInputData,\n  ConfigType = DefaultConfigData,\n> = (context: AgentFunctionContext<ParamsType, NamedInputDataType, ConfigType>) => Promise<ResultData<ResultType>>;\n\nexport type AgentFilterFunction<ParamsType = DefaultParamsType, ResultType = DefaultResultData, NamedInputDataType = DefaultInputData> = (\n  context: AgentFunctionContext<ParamsType, NamedInputDataType>,\n  agent: AgentFunction,\n) => Promise<ResultData<ResultType>>;\n\nexport type AgentFilterInfo = {\n  name: string;\n  agent: AgentFilterFunction;\n  agentIds?: string[];\n  nodeIds?: string[];\n  filterParams?: AgentFilterParams;\n};\n\nexport type AgentFunctionInfoSample = {\n  inputs: any;\n  params: DefaultParamsType;\n  result: any;\n  graph?: GraphData;\n  description?: string;\n};\n\nexport type AgentFunctionInfo = {\n  name: string;\n  agent: AgentFunction<any, any, any, any>;\n  mock: AgentFunction<any, any, any, any>;\n  inputs?: any; // inputs data schema\n  output?: any; // output data schema\n  params?: any; // params data schema\n  config?: any; // config data schema\n  outputFormat?: any;\n  tools?: Record<string, any>[]; // function calling(tools) schema.\n  samples: AgentFunctionInfoSample[]; // sample data. This is for document and unit test.\n  description: string;\n  category: string[];\n  author: string;\n  repository: string;\n  source?: string;\n  package?: string;\n  license: string;\n  cacheType?: CacheTypes;\n  environmentVariables?: string[]; // Environment variables required for execution\n  hasGraphData?: boolean; // The agent that executes graph data using nestedAgentGenerator is true\n  stream?: boolean; // is stream support?\n  apiKeys?: string[];\n  npms?: string[];\n};\n\nexport type AgentFunctionInfoDictionary = Record<string, AgentFunctionInfo>;\n\nexport type PropFunction = (result: ResultData, propId: string) => ResultData;\n\nexport type CallbackFunction = (log: TransactionLog, isUpdate: boolean) => void;\n","type LogLevel = \"debug\" | \"info\" | \"log\" | \"warn\" | \"error\";\ntype LoggerFunction = (level: LogLevel, ...args: any[]) => void;\n\nconst enabledLevels: Record<LogLevel, boolean> = {\n  debug: true,\n  info: true,\n  log: true,\n  warn: true,\n  error: true,\n};\n\nlet customLogger: LoggerFunction | null = null;\n\nfunction setLevelEnabled(level: LogLevel, enabled: boolean) {\n  enabledLevels[level] = enabled;\n}\n\nfunction setLogger(logger: LoggerFunction) {\n  customLogger = logger;\n}\n\nfunction output(level: LogLevel, ...args: any[]) {\n  if (!enabledLevels[level]) return;\n  if (customLogger) {\n    customLogger(level, ...args);\n  } else {\n    (console[level] || console.log)(...args);\n  }\n}\n\nfunction debug(...args: any[]) {\n  output(\"debug\", ...args);\n}\nfunction info(...args: any[]) {\n  output(\"info\", ...args);\n}\nfunction log(...args: any[]) {\n  output(\"log\", ...args);\n}\nfunction warn(...args: any[]) {\n  output(\"warn\", ...args);\n}\nfunction error(...args: any[]) {\n  output(\"error\", ...args);\n}\n\nexport const GraphAILogger = {\n  setLevelEnabled,\n  setLogger,\n  debug,\n  info,\n  log,\n  warn,\n  error,\n};\n","import { PropFunction } from \"../type\";\nimport { isObject, loopCounterKey } from \"./utils\";\nimport { GraphNodes } from \"../node\";\nimport { GraphAILogger } from \"./GraphAILogger\";\n\nexport const propFunctionRegex = /^[a-zA-Z]+\\([^)]*\\)$/;\n\nconst propArrayFunction: PropFunction = (result, propId) => {\n  if (Array.isArray(result)) {\n    if (propId === \"length()\") {\n      return result.length;\n    }\n    if (propId === \"flat()\") {\n      return result.flat();\n    }\n    if (propId === \"toJSON()\") {\n      return JSON.stringify(result, null, 2);\n    }\n    if (propId === \"isEmpty()\") {\n      return result.length === 0;\n    }\n    if (propId === \"average()\" || propId === \"mean()\") {\n      return result.length ? result.reduce((a, b) => a + b, 0) / result.length : 0;\n    }\n    if (propId === \"sum()\") {\n      return result.reduce((a, b) => a + b, 0);\n    }\n    if (propId === \"max()\") {\n      return result.length ? Math.max(...result) : 0;\n    }\n    if (propId === \"min()\") {\n      return result.length ? Math.min(...result) : 0;\n    }\n\n    // array join\n    const matchJoin = propId.match(/^join\\(([,-\\s]?)\\)$/);\n    if (matchJoin && Array.isArray(matchJoin)) {\n      return result.join(matchJoin[1] ?? \"\");\n    }\n  }\n  return undefined;\n};\n\nconst propObjectFunction: PropFunction = (result, propId) => {\n  if (isObject(result)) {\n    if (propId === \"keys()\") {\n      return Object.keys(result);\n    }\n    if (propId === \"values()\") {\n      return Object.values(result);\n    }\n    if (propId === \"toJSON()\") {\n      return JSON.stringify(result, null, 2);\n    }\n  }\n  return undefined;\n};\n\nconst propStringFunction: PropFunction = (result, propId) => {\n  if (typeof result === \"string\") {\n    if (propId === \"codeBlock()\") {\n      const match = (\"\\n\" + result).match(/\\n```[a-zA-Z]*([\\s\\S]*?)\\n```/);\n      if (match) {\n        return match[1];\n      }\n    }\n    if (propId === \"codeBlockOrRaw()\") {\n      const match = (\"\\n\" + result).match(/\\n```[a-zA-Z]*([\\s\\S]*?)\\n```/);\n      if (match) {\n        return match[1];\n      }\n      return result;\n    }\n    if (propId === \"jsonParse()\") {\n      return JSON.parse(result);\n    }\n    if (propId === \"toNumber()\") {\n      const ret = Number(result);\n      if (!isNaN(ret)) {\n        return ret;\n      }\n    }\n    if (propId === \"trim()\") {\n      return result.trim();\n    }\n    if (propId === \"toLowerCase()\") {\n      return result.toLowerCase();\n    }\n    if (propId === \"toUpperCase()\") {\n      return result.toUpperCase();\n    }\n    const equalMatch = propId.match(/^equal\\(([A-Za-z0-9!#$%&()*+,\\-./:;<=>?@]+)\\)/);\n    if (equalMatch) {\n      return result === equalMatch[1];\n    }\n\n    const sliceMatch = propId.match(/^slice\\((-?\\d+)(?:,\\s*(-?\\d+))?\\)/);\n    if (sliceMatch) {\n      if (sliceMatch[2] !== undefined) {\n        return result.slice(Number(sliceMatch[1]), Number(sliceMatch[2]));\n      }\n      if (sliceMatch[1] !== undefined) {\n        return result.slice(Number(sliceMatch[1]));\n      }\n      GraphAILogger.warn(\"slice is not valid format: \" + sliceMatch);\n    }\n\n    const splitMatch = propId.match(/^split\\(([-_:;.,\\s\\n]+)\\)$/);\n    if (splitMatch) {\n      return result.split(splitMatch[1]);\n    }\n  }\n  return undefined;\n};\nconst propNumberFunction: PropFunction = (result, propId) => {\n  if (result !== undefined && Number.isFinite(result)) {\n    if (propId === \"toString()\") {\n      return String(result);\n    }\n    const regex = /^add\\((-?\\d+)\\)$/;\n    const match = propId.match(regex);\n    if (match) {\n      return Number(result) + Number(match[1]);\n    }\n\n    const equalMatch = propId.match(/^equal\\(([A-Za-z0-9!#$%&()*+,\\-/:;<=>?@]+)\\)/);\n    if (equalMatch) {\n      return result === Number(equalMatch[1]);\n    }\n  }\n  return undefined;\n};\nconst propBooleanFunction: PropFunction = (result, propId) => {\n  if (typeof result === \"boolean\") {\n    if (propId === \"not()\") {\n      return !result;\n    }\n  }\n  return undefined;\n};\n\nconst propUndefinrdFunction: PropFunction = (result, propId) => {\n  if (result === undefined) {\n    const equalMatch = propId.match(/^default\\(([A-Za-z0-9!#$%&()*+,\\-/:;<=>?@]+)\\)/);\n    if (equalMatch) {\n      if (equalMatch[1].match(/^[0-9-]+$/)) {\n        return Number(equalMatch[1]);\n      }\n      return equalMatch[1];\n    }\n  }\n  return undefined;\n};\n\n// TODO if (result === undefined) {default()}\n\nexport const propFunctions = [propArrayFunction, propObjectFunction, propStringFunction, propNumberFunction, propBooleanFunction, propUndefinrdFunction];\n\nexport const utilsFunctions = (input: string, nodes: GraphNodes) => {\n  if (input === \"@now\" || input === \"@now_ms\") {\n    return Date.now();\n  }\n  if (input === \"@now_s\") {\n    return Math.floor(Date.now() / 1000);\n  }\n  if (input === \"@loop\") {\n    return nodes[loopCounterKey].result as string;\n  }\n  // If a placeholder does not match any key, replace it with an empty string.\n  GraphAILogger.warn(\"not match template utility function: ${\" + input + \"}\");\n  return \"\";\n};\n","import { DataSource, AgentFunction, AgentFunctionInfo, NodeData, StaticNodeData, ComputedNodeData, NodeState } from \"../type\";\nimport type { GraphNodes } from \"../node\";\nimport { GraphAILogger } from \"./GraphAILogger\";\nimport { utilsFunctions } from \"./prop_function\";\n\nexport const sleep = async (milliseconds: number) => {\n  return await new Promise((resolve) => setTimeout(resolve, milliseconds));\n};\n\nexport const parseNodeName = (inputNodeId: any, isSelfNode: boolean = false, nodes?: GraphNodes): DataSource => {\n  if (isSelfNode) {\n    if (typeof inputNodeId === \"string\" && inputNodeId[0] === \".\") {\n      const parts = inputNodeId.split(\".\");\n      return { nodeId: \"self\", propIds: parts.slice(1) };\n    }\n    return { value: inputNodeId };\n  }\n  if (typeof inputNodeId === \"string\") {\n    const regex = /^:(.*)$/;\n    const match = inputNodeId.match(regex);\n    if (match) {\n      const parts = match[1].split(/(?<!\\()\\.(?!\\))/);\n      if (parts.length == 1) {\n        return { nodeId: parts[0] };\n      }\n      return { nodeId: parts[0], propIds: parts.slice(1) };\n    }\n    const regexUtil = /^@(.*)$/;\n    const matchUtil = inputNodeId.match(regexUtil);\n    // Only when just called from resultsOfInner\n    if (nodes && matchUtil) {\n      return { value: utilsFunctions(inputNodeId, nodes) };\n    }\n  }\n  return { value: inputNodeId }; // non-string literal\n};\n\nexport function assert(condition: boolean, message: string, isWarn: boolean = false): asserts condition {\n  if (!condition) {\n    if (!isWarn) {\n      throw new Error(message);\n    }\n    GraphAILogger.warn(\"warn: \" + message);\n  }\n}\n\nexport const isObject = <Values = unknown>(x: unknown): x is Record<string, Values> => {\n  return x !== null && typeof x === \"object\";\n};\n\nexport const isNull = (data: unknown) => {\n  return data === null || data === undefined;\n};\n\nexport const strIntentionalError = \"Intentional Error for Debugging\";\n\nexport const defaultAgentInfo = {\n  name: \"defaultAgentInfo\",\n  samples: [\n    {\n      inputs: [],\n      params: {},\n      result: {},\n    },\n  ],\n  description: \"\",\n  category: [],\n  author: \"\",\n  repository: \"\",\n  license: \"\",\n};\n\nexport const agentInfoWrapper = (agent: AgentFunction<any, any, any, any>): AgentFunctionInfo => {\n  return {\n    agent,\n    mock: agent,\n    ...defaultAgentInfo,\n  };\n};\n\nconst objectToKeyArray = (innerData: any) => {\n  const ret: string[][] = [];\n  Object.keys(innerData).forEach((key: string) => {\n    ret.push([key]);\n    if (Object.keys(innerData[key]).length > 0) {\n      objectToKeyArray(innerData[key]).forEach((tmp: string[]) => {\n        ret.push([key, ...tmp]);\n      });\n    }\n  });\n  return ret;\n};\n\nexport const debugResultKey = (agentId: string, result: any) => {\n  return objectToKeyArray({ [agentId]: debugResultKeyInner(result) }).map((objectKeys: string[]) => {\n    return \":\" + objectKeys.join(\".\");\n  });\n};\n\nconst debugResultKeyInner = (result: any) => {\n  if (result === null || result === undefined) {\n    return {};\n  }\n  if (typeof result === \"string\") {\n    return {};\n  }\n  if (Array.isArray(result)) {\n    return Array.from(result.keys()).reduce((tmp: Record<string, any>, index: number) => {\n      tmp[\"$\" + String(index)] = debugResultKeyInner(result[index]);\n      return tmp;\n    }, {});\n  }\n  return Object.keys(result).reduce((tmp: Record<string, any>, key: string) => {\n    tmp[key] = debugResultKeyInner(result[key]);\n    return tmp;\n  }, {});\n};\n\nexport const isLogicallyTrue = (value: any) => {\n  // Notice that empty aray is not true under GraphAI\n  if (Array.isArray(value) ? value.length === 0 : !value) {\n    return false;\n  }\n  return true;\n};\n\nexport const defaultTestContext = {\n  debugInfo: {\n    nodeId: \"test\",\n    retry: 0,\n    verbose: true,\n    state: NodeState.Executing,\n    subGraphs: new Map(),\n  },\n  params: {},\n  filterParams: {},\n  agents: {},\n  log: [],\n};\n\nexport const isNamedInputs = <Values = unknown>(namedInputs: unknown): namedInputs is Record<string, Values> => {\n  return isObject(namedInputs) && !Array.isArray(namedInputs) && Object.keys(namedInputs || {}).length > 0;\n};\n\nexport const isComputedNodeData = (node: NodeData): node is ComputedNodeData => {\n  return \"agent\" in node;\n};\n\nexport const isStaticNodeData = (node: NodeData): node is StaticNodeData => {\n  return !(\"agent\" in node);\n};\n\nexport const loopCounterKey: string = \"__loopIndex\";\n","import { parseNodeName, isObject } from \"./utils\";\nimport { DataSource } from \"../type\";\n\n// for dataSource\nexport const inputs2dataSources = (inputs: any): DataSource[] => {\n  if (Array.isArray(inputs)) {\n    return inputs.map((inp) => inputs2dataSources(inp)).flat();\n  }\n  if (isObject(inputs)) {\n    return Object.values(inputs)\n      .map((input) => inputs2dataSources(input))\n      .flat();\n  }\n  if (typeof inputs === \"string\") {\n    const templateMatch = [...inputs.matchAll(/\\${(:[^}]+)}/g)].map((m) => m[1]);\n    if (templateMatch.length > 0) {\n      return inputs2dataSources(templateMatch);\n    }\n  }\n\n  return parseNodeName(inputs) as any;\n};\n\n// TODO: Maybe it's a remnant of old array inputs. Check and delete.\nexport const dataSourceNodeIds = (sources: DataSource[]): string[] => {\n  if (!Array.isArray(sources)) {\n    throw new Error(\"sources must be array!! maybe inputs is invalid\");\n  }\n  return sources.filter((source: DataSource) => source.nodeId).map((source) => source.nodeId!);\n};\n","import { ResultData, NodeDataParams, NodeState } from \"./type\";\nimport type { GraphAI } from \"./graphai\";\nimport type { ComputedNode, StaticNode } from \"./node\";\nimport { debugResultKey } from \"./utils/utils\";\nimport { dataSourceNodeIds } from \"./utils/nodeUtils\";\n\nexport class TransactionLog {\n  public nodeId: string;\n  public state: NodeState;\n  public startTime?: number;\n  public endTime?: number;\n  public retryCount?: number;\n  public agentId?: string;\n  public params?: NodeDataParams;\n  public inputs?: string[];\n  public inputsData?: Array<ResultData>;\n  public injectFrom?: string;\n  public errorMessage?: string;\n  public result?: ResultData;\n  public resultKeys?: string[];\n  public mapIndex?: number;\n  public isLoop?: boolean;\n  public repeatCount?: number;\n  public log?: TransactionLog[];\n  constructor(nodeId: string, mapIndex?: number) {\n    this.nodeId = nodeId;\n    this.state = NodeState.Waiting;\n    this.mapIndex = mapIndex;\n  }\n\n  public initForComputedNode(node: ComputedNode, graph: GraphAI) {\n    this.agentId = node.getAgentId();\n    this.params = node.params;\n    graph.appendLog(this);\n  }\n\n  public onInjected(node: StaticNode, graph: GraphAI, injectFrom?: string) {\n    const isUpdating = \"endTime\" in this;\n    this.result = node.result;\n    this.state = node.state;\n    this.endTime = Date.now();\n    this.injectFrom = injectFrom;\n    graph.setLoopLog(this);\n    // console.log(this)\n    if (isUpdating) {\n      graph.updateLog(this);\n    } else {\n      graph.appendLog(this);\n    }\n  }\n\n  public onComplete(node: ComputedNode, graph: GraphAI, localLog: TransactionLog[]) {\n    this.result = node.result;\n    this.resultKeys = debugResultKey(this.agentId || \"\", node.result);\n    this.state = node.state;\n    this.endTime = Date.now();\n    graph.setLoopLog(this);\n    if (localLog.length > 0) {\n      this.log = localLog;\n    }\n    graph.updateLog(this);\n  }\n\n  public beforeExecute(node: ComputedNode, graph: GraphAI, transactionId: number, inputs: ResultData[]) {\n    this.state = node.state;\n    this.retryCount = node.retryCount > 0 ? node.retryCount : undefined;\n    this.startTime = transactionId;\n    this.inputs = dataSourceNodeIds(node.dataSources);\n    this.inputsData = inputs.length > 0 ? inputs : undefined;\n    graph.setLoopLog(this);\n    graph.appendLog(this);\n  }\n\n  public beforeAddTask(node: ComputedNode, graph: GraphAI) {\n    this.state = node.state;\n    graph.setLoopLog(this);\n    graph.appendLog(this);\n  }\n\n  public onError(node: ComputedNode, graph: GraphAI, errorMessage: string) {\n    this.state = node.state;\n    this.errorMessage = errorMessage;\n    this.endTime = Date.now();\n    graph.setLoopLog(this);\n    graph.updateLog(this);\n  }\n\n  public onSkipped(node: ComputedNode, graph: GraphAI) {\n    this.state = node.state;\n    graph.setLoopLog(this);\n    graph.updateLog(this);\n  }\n}\n","import { ResultData, DataSource, PropFunction } from \"../type\";\nimport { isObject, isNull } from \"./utils\";\nimport { propFunctionRegex } from \"./prop_function\";\nimport { GraphAILogger } from \"./GraphAILogger\";\n\nconst getNestedData = (result: ResultData, propId: string, propFunctions: PropFunction[]) => {\n  const match = propId.match(propFunctionRegex);\n  if (match) {\n    for (const propFunction of propFunctions) {\n      const ret = propFunction(result, propId);\n      if (!isNull(ret)) {\n        return ret;\n      }\n    }\n  }\n\n  // for array.\n  if (Array.isArray(result)) {\n    // $0, $1. array value.\n    const regex = /^\\$(\\d+)$/;\n    const match = propId.match(regex);\n    if (match) {\n      const index = parseInt(match[1], 10);\n      return result[index];\n    }\n    if (propId === \"$last\") {\n      return result[result.length - 1];\n    }\n  } else if (isObject(result)) {\n    if (propId in result) {\n      return result[propId];\n    }\n  }\n  return undefined;\n};\n\nconst innerGetDataFromSource = (result: ResultData, propIds: string[] | undefined, propFunctions: PropFunction[]): ResultData | undefined => {\n  if (propIds && propIds.length > 0) {\n    const propId = propIds[0];\n    const ret = getNestedData(result, propId, propFunctions);\n    if (ret === undefined) {\n      GraphAILogger.error(`prop: ${propIds.join(\".\")} is not hit`);\n    }\n    if (propIds.length > 1) {\n      return innerGetDataFromSource(ret, propIds.slice(1), propFunctions);\n    }\n    return ret;\n  }\n  return result;\n};\n\nexport const getDataFromSource = (result: ResultData | undefined, source: DataSource, propFunctions: PropFunction[] = []): ResultData | undefined => {\n  if (!source.nodeId) {\n    return source.value;\n  }\n  return innerGetDataFromSource(result, source.propIds, propFunctions);\n};\n","import { DataSource, ResultData, PropFunction } from \"../type\";\n\nimport { GraphNodes } from \"../node\";\n\nimport { parseNodeName, isNamedInputs, isObject, isNull } from \"./utils\";\nimport { getDataFromSource } from \"./data_source\";\nimport { utilsFunctions } from \"./prop_function\";\n\nconst replaceTemplatePlaceholders = (input: string, templateMatch: string[], nodes: GraphNodes, propFunctions: PropFunction[], isSelfNode: boolean) => {\n  // GOD format ${:node.prop1.prop2}\n  const godResults = resultsOfInner(\n    templateMatch.filter((text) => text.startsWith(\":\")),\n    nodes,\n    propFunctions,\n    isSelfNode,\n  );\n  // utilsFunctions ${@now}\n  const utilsFuncResult = templateMatch\n    .filter((text) => text.startsWith(\"@\"))\n    .reduce((tmp: Record<string, string | number>, key: string) => {\n      tmp[key] = utilsFunctions(key, nodes);\n      return tmp;\n    }, {});\n  return Array.from(templateMatch.keys()).reduce((tmp, key) => {\n    if (templateMatch[key].startsWith(\":\")) {\n      return tmp.replaceAll(\"${\" + templateMatch[key] + \"}\", (godResults as any)[key]);\n    }\n    return tmp.replaceAll(\"${\" + templateMatch[key] + \"}\", (utilsFuncResult as any)[templateMatch[key]]);\n  }, input);\n};\n\nconst resultsOfInner = (input: any, nodes: GraphNodes, propFunctions: PropFunction[], isSelfNode: boolean = false): ResultData => {\n  if (Array.isArray(input)) {\n    return input.map((inp) => resultsOfInner(inp, nodes, propFunctions, isSelfNode));\n  }\n  if (isNamedInputs(input)) {\n    return resultsOf(input, nodes, propFunctions, isSelfNode);\n  }\n  if (typeof input === \"string\") {\n    const templateMatch = [...input.matchAll(/\\${([:@][^}]+)}/g)].map((m) => m[1]);\n    if (templateMatch.length > 0) {\n      return replaceTemplatePlaceholders(input, templateMatch, nodes, propFunctions, isSelfNode);\n    }\n  }\n  // :node.prod\n  return resultOf(parseNodeName(input, isSelfNode, nodes), nodes, propFunctions);\n};\n\nexport const resultsOf = (inputs: Record<string, any>, nodes: GraphNodes, propFunctions: PropFunction[], isSelfNode: boolean = false) => {\n  return Object.keys(inputs).reduce((tmp: Record<string, ResultData>, key) => {\n    const input = inputs[key];\n    tmp[key] = isNamedInputs(input) ? resultsOf(input, nodes, propFunctions, isSelfNode) : resultsOfInner(input, nodes, propFunctions, isSelfNode);\n    return tmp;\n  }, {});\n};\n\nexport const resultOf = (source: DataSource, nodes: GraphNodes, propFunctions: PropFunction[]) => {\n  const { result } = source.nodeId ? nodes[source.nodeId] : { result: undefined };\n  return getDataFromSource(result, source, propFunctions);\n};\n\n// clean up object for anyInput\nexport const cleanResultInner = (results: ResultData): ResultData | null => {\n  if (Array.isArray(results)) {\n    return results.map((result: ResultData) => cleanResultInner(result)).filter((result) => !isNull(result));\n  }\n\n  if (isObject<ResultData>(results)) {\n    return Object.keys(results).reduce((tmp: Record<string, ResultData>, key: string) => {\n      const value = cleanResultInner(results[key]);\n      if (!isNull(value)) {\n        tmp[key] = value;\n      }\n      return tmp;\n    }, {});\n  }\n\n  return results;\n};\n\nexport const cleanResult = (results: Record<string, ResultData | undefined>) => {\n  return Object.keys(results).reduce((tmp: Record<string, ResultData | undefined>, key: string) => {\n    const value = cleanResultInner(results[key]);\n    if (!isNull(value)) {\n      tmp[key] = value;\n    }\n    return tmp;\n  }, {});\n};\n","import type { GraphAI, GraphData } from \"./index\";\nimport { strIntentionalError, isNamedInputs, isNull } from \"./utils/utils\";\nimport { inputs2dataSources, dataSourceNodeIds } from \"./utils/nodeUtils\";\n\nimport {\n  NodeDataParams,\n  ResultData,\n  DataSource,\n  ComputedNodeData,\n  StaticNodeData,\n  NodeState,\n  AgentFunctionContext,\n  AgentFunction,\n  AgentFilterInfo,\n  AgentFilterParams,\n  AgentFunctionContextDebugInfo,\n  DefaultParamsType,\n  DefaultInputData,\n  PassThrough,\n  ConsoleElement,\n  ConfigData,\n  RepeatUntil,\n} from \"./type\";\nimport { parseNodeName, assert, isLogicallyTrue, isObject } from \"./utils/utils\";\nimport { TransactionLog } from \"./transaction_log\";\nimport { resultsOf } from \"./utils/result\";\nimport { GraphAILogger } from \"./utils/GraphAILogger\";\n\nexport class Node {\n  public readonly nodeId: string;\n  public readonly waitlist = new Set<string>(); // List of nodes which need data from this node.\n  public state = NodeState.Waiting;\n  public result: ResultData | undefined = undefined;\n\n  protected graph: GraphAI;\n  protected log: TransactionLog;\n  protected console: ConsoleElement; // console output option (before and/or after)\n\n  constructor(nodeId: string, graph: GraphAI) {\n    this.nodeId = nodeId;\n    this.graph = graph;\n    this.log = new TransactionLog(nodeId, this.graph.mapIndex);\n    this.console = {};\n  }\n\n  public asString() {\n    return `${this.nodeId}: ${this.state} ${[...this.waitlist]}`;\n  }\n\n  // This method is called either as the result of computation (computed node) or\n  // injection (static node).\n  protected onSetResult() {\n    this.waitlist.forEach((waitingNodeId) => {\n      const waitingNode = this.graph.nodes[waitingNodeId];\n      if (waitingNode.isComputedNode) {\n        waitingNode.removePending(this.nodeId);\n        this.graph.pushQueueIfReadyAndRunning(waitingNode);\n      }\n    });\n  }\n\n  protected afterConsoleLog(result: ResultData) {\n    if (this.console === false) {\n      return;\n    } else if (this.console === true || this.console.after === true) {\n      GraphAILogger.log(typeof result === \"string\" ? result : JSON.stringify(result, null, 2));\n    } else if (this.console.after) {\n      if (isObject(this.console.after)) {\n        GraphAILogger.log(\n          JSON.stringify(resultsOf(this.console.after, { self: { result } as unknown as ComputedNode | StaticNode }, this.graph.propFunctions, true), null, 2),\n        );\n      } else {\n        GraphAILogger.log(this.console.after);\n      }\n    }\n  }\n}\n\nexport class ComputedNode extends Node {\n  public readonly graphId: string;\n  public readonly isResult: boolean;\n  public readonly params: NodeDataParams; // Agent-specific parameters\n  private readonly filterParams: AgentFilterParams;\n  public readonly nestedGraph?: GraphData | DataSource;\n  public readonly retryLimit: number;\n  public retryCount: number = 0;\n  private readonly repeatUntil?: RepeatUntil;\n  private readonly agentId?: string;\n  private agentFunction?: AgentFunction<any, any, any, any>;\n  public readonly timeout?: number; // msec\n  public readonly priority: number;\n  public error?: Error;\n  public transactionId: undefined | number; // To reject callbacks from timed-out transactions\n  private readonly passThrough?: PassThrough;\n\n  public readonly anyInput: boolean; // any input makes this node ready\n  public dataSources: DataSource[] = []; // no longer needed. This is for transaction log.\n  private inputs?: Record<string, any>;\n  private output?: Record<string, any>;\n  public pendings: Set<string>; // List of nodes this node is waiting data from.\n  private ifSource?: DataSource; // conditional execution\n  private unlessSource?: DataSource; // conditional execution\n  private defaultValue?: ResultData;\n  private isSkip: boolean = false;\n  private debugInfo?: AgentFunctionContextDebugInfo;\n  public readonly isStaticNode = false;\n  public readonly isComputedNode = true;\n\n  constructor(graphId: string, nodeId: string, data: ComputedNodeData, graph: GraphAI) {\n    super(nodeId, graph);\n    this.graphId = graphId;\n    this.params = data.params ?? {};\n    this.console = data.console ?? {};\n    this.filterParams = data.filterParams ?? {};\n    this.passThrough = data.passThrough;\n    this.retryLimit = data.retry ?? graph.retryLimit ?? 0;\n    this.repeatUntil = data.repeatUntil;\n    this.timeout = data.timeout;\n    this.isResult = data.isResult ?? false;\n    this.priority = data.priority ?? 0;\n\n    assert([\"function\", \"string\"].includes(typeof data.agent), \"agent must be either string or function\");\n    if (typeof data.agent === \"string\") {\n      this.agentId = data.agent;\n    } else {\n      const agent = data.agent;\n      this.agentFunction = async ({ namedInputs, params }) => agent(namedInputs, params);\n    }\n\n    this.anyInput = data.anyInput ?? false;\n    this.inputs = data.inputs;\n    this.output = data.output;\n    this.dataSources = [\n      ...(data.inputs ? inputs2dataSources(data.inputs).flat(10) : []),\n      // ...(data.params ? inputs2dataSources(data.params).flat(10) : []),\n      ...(this.agentId ? [parseNodeName(this.agentId)] : []),\n      ...(data.passThrough ? inputs2dataSources(data.passThrough).flat(10) : []),\n    ];\n    if (data.inputs && Array.isArray(data.inputs)) {\n      throw new Error(`array inputs have been deprecated. nodeId: ${nodeId}: see https://github.com/receptron/graphai/blob/main/docs/NamedInputs.md`);\n    }\n\n    this.pendings = new Set(dataSourceNodeIds(this.dataSources));\n    if (data.graph) {\n      this.nestedGraph = typeof data.graph === \"string\" ? this.addPendingNode(data.graph) : data.graph;\n    }\n    if (data.graphLoader && graph.graphLoader) {\n      this.nestedGraph = graph.graphLoader(data.graphLoader);\n    }\n    if (data.if) {\n      this.ifSource = this.addPendingNode(data.if);\n    }\n    if (data.unless) {\n      this.unlessSource = this.addPendingNode(data.unless);\n    }\n    if (data.defaultValue) {\n      this.defaultValue = data.defaultValue;\n    }\n    this.isSkip = false;\n    this.log.initForComputedNode(this, graph);\n  }\n\n  public getAgentId() {\n    return this.agentId ?? \"__custom__function\"; // only for display purpose in the log.\n  }\n\n  private getConfig(hasGraphData: boolean, agentId?: string) {\n    if (agentId) {\n      if (hasGraphData) {\n        return this.graph.config;\n      }\n      const config = this.graph.config ?? {};\n      return {\n        ...(config[\"global\"] ?? {}),\n        ...(config[agentId] ?? {}),\n      };\n    }\n    return {};\n  }\n\n  private addPendingNode(nodeId: string) {\n    const source = parseNodeName(nodeId);\n    assert(!!source.nodeId, `Invalid data source ${nodeId}`);\n    this.pendings.add(source.nodeId);\n    return source;\n  }\n\n  private updateState(state: NodeState) {\n    this.state = state;\n    if (this.debugInfo) {\n      this.debugInfo.state = state;\n    }\n  }\n\n  public resetPending() {\n    this.pendings.clear();\n    if (this.state === NodeState.Executing) {\n      this.updateState(NodeState.Abort);\n    }\n    if (this.debugInfo && this.debugInfo.subGraphs) {\n      this.debugInfo.subGraphs.forEach((graph) => graph.abort(true));\n    }\n  }\n\n  public isReadyNode() {\n    if (this.state !== NodeState.Waiting || this.pendings.size !== 0) {\n      return false;\n    }\n    this.isSkip = !!(\n      (this.ifSource && !isLogicallyTrue(this.graph.resultOf(this.ifSource))) ||\n      (this.unlessSource && isLogicallyTrue(this.graph.resultOf(this.unlessSource)))\n    );\n\n    if (this.isSkip && this.defaultValue === undefined) {\n      this.updateState(NodeState.Skipped);\n      this.log.onSkipped(this, this.graph);\n      return false;\n    }\n    return true;\n  }\n\n  // This private method (only called while executing execute()) performs\n  // the \"retry\" if specified. The transaction log must be updated before\n  // callling this method.\n  private retry(state: NodeState, error: Error) {\n    this.updateState(state); // this.execute() will update to NodeState.Executing\n    this.log.onError(this, this.graph, error.message);\n\n    if (this.retryCount < this.retryLimit) {\n      this.retryCount++;\n      this.execute();\n    } else {\n      this.result = undefined;\n      this.error = error;\n      this.transactionId = undefined; // This is necessary for timeout case\n      this.graph.onExecutionComplete(this);\n    }\n  }\n\n  private checkDataAvailability() {\n    return Object.values(this.graph.resultsOf(this.inputs))\n      .flat()\n      .some((result) => result !== undefined);\n  }\n\n  // This method is called right before the Graph add this node to the task manager.\n  public beforeAddTask() {\n    this.updateState(NodeState.Queued);\n    this.log.beforeAddTask(this, this.graph);\n  }\n\n  // This method is called when the data became available on one of nodes,\n  // which this node needs data from.\n  public removePending(nodeId: string) {\n    if (this.anyInput) {\n      if (this.checkDataAvailability()) {\n        this.pendings.clear();\n      }\n    } else {\n      this.pendings.delete(nodeId);\n    }\n  }\n\n  private isCurrentTransaction(transactionId: number) {\n    return this.transactionId === transactionId;\n  }\n\n  // This private method (called only fro execute) checks if the callback from\n  // the timer came before the completion of agent function call, record it\n  // and attempt to retry (if specified).\n  private executeTimeout(transactionId: number) {\n    if (this.state === NodeState.Executing && this.isCurrentTransaction(transactionId)) {\n      GraphAILogger.warn(`-- timeout ${this.timeout} with ${this.nodeId}`);\n      this.retry(NodeState.TimedOut, Error(\"Timeout\"));\n    }\n  }\n\n  // Check if we need to apply this filter to this node or not.\n  private shouldApplyAgentFilter(agentFilter: AgentFilterInfo, agentId?: string) {\n    if (agentFilter.agentIds && Array.isArray(agentFilter.agentIds) && agentFilter.agentIds.length > 0) {\n      if (agentId && agentFilter.agentIds.includes(agentId)) {\n        return true;\n      }\n    }\n    if (agentFilter.nodeIds && Array.isArray(agentFilter.nodeIds) && agentFilter.nodeIds.length > 0) {\n      if (agentFilter.nodeIds.includes(this.nodeId)) {\n        return true;\n      }\n    }\n    return !agentFilter.agentIds && !agentFilter.nodeIds;\n  }\n\n  private agentFilterHandler(context: AgentFunctionContext, agentFunction: AgentFunction, agentId?: string): Promise<ResultData> {\n    let index = 0;\n\n    const next = (innerContext: AgentFunctionContext): Promise<ResultData> => {\n      const agentFilter = this.graph.agentFilters[index++];\n      if (agentFilter) {\n        if (this.shouldApplyAgentFilter(agentFilter, agentId)) {\n          if (agentFilter.filterParams) {\n            innerContext.filterParams = { ...agentFilter.filterParams, ...innerContext.filterParams };\n          }\n          return agentFilter.agent(innerContext, next);\n        }\n        return next(innerContext);\n      }\n      return agentFunction(innerContext);\n    };\n\n    return next(context);\n  }\n\n  // This method is called when this computed node became ready to run.\n  // It asynchronously calls the associated with agent function and set the result,\n  // then it removes itself from the \"running node\" list of the graph.\n  // Notice that setting the result of this node may make other nodes ready to run.\n  public async execute() {\n    if (this.isSkip) {\n      this.afterExecute(this.defaultValue, []);\n      return;\n    }\n    const previousResults = this.graph.resultsOf(this.inputs, this.anyInput);\n    const agentId = this.agentId ? (this.graph.resultOf(parseNodeName(this.agentId)) as string) : this.agentId;\n    if (typeof agentId === \"function\") {\n      this.agentFunction = agentId;\n    }\n    const hasNestedGraph = Boolean(this.nestedGraph) || Boolean(agentId && this.graph.getAgentFunctionInfo(agentId).hasGraphData);\n    const config: ConfigData | undefined = this.getConfig(hasNestedGraph, agentId);\n\n    const transactionId = Date.now();\n    this.prepareExecute(transactionId, Object.values(previousResults));\n\n    if (this.timeout && this.timeout > 0) {\n      setTimeout(() => {\n        this.executeTimeout(transactionId);\n      }, this.timeout);\n    }\n\n    try {\n      const agentFunction = this.agentFunction ?? this.graph.getAgentFunctionInfo(agentId).agent;\n      const localLog: TransactionLog[] = [];\n      const context = this.getContext(previousResults, localLog, agentId, config);\n\n      // NOTE: We use the existence of graph object in the agent-specific params to determine\n      // if this is a nested agent or not.\n      if (hasNestedGraph) {\n        this.graph.taskManager.prepareForNesting();\n        context.forNestedGraph = {\n          graphData: this.nestedGraph\n            ? \"nodes\" in this.nestedGraph\n              ? this.nestedGraph\n              : (this.graph.resultOf(this.nestedGraph) as GraphData) // HACK: compiler work-around\n            : { version: 0, nodes: {} },\n          agents: this.graph.agentFunctionInfoDictionary,\n          graphOptions: {\n            agentFilters: this.graph.agentFilters,\n            taskManager: this.graph.taskManager,\n            bypassAgentIds: this.graph.bypassAgentIds,\n            config,\n            graphLoader: this.graph.graphLoader,\n          },\n          onLogCallback: this.graph.onLogCallback,\n          callbacks: this.graph.callbacks,\n        };\n      }\n\n      this.beforeConsoleLog(context);\n      const result = await this.agentFilterHandler(context as AgentFunctionContext, agentFunction, agentId);\n      this.afterConsoleLog(result);\n\n      if (hasNestedGraph) {\n        this.graph.taskManager.restoreAfterNesting();\n      }\n\n      if (!this.isCurrentTransaction(transactionId)) {\n        // This condition happens when the agent function returns\n        // after the timeout (either retried or not).\n        GraphAILogger.log(`-- transactionId mismatch with ${this.nodeId} (probably timeout)`);\n        return;\n      }\n\n      if (this.repeatUntil?.exists) {\n        const dummyResult = { self: { result: this.getResult(result) } as unknown as ComputedNode };\n        const repeatResult = resultsOf({ data: this.repeatUntil?.exists }, dummyResult, [], true);\n        if (isNull(repeatResult?.data)) {\n          this.retry(NodeState.Failed, Error(\"Repeat Until\"));\n          return;\n        }\n      }\n\n      // after process\n      this.afterExecute(result, localLog);\n    } catch (error) {\n      this.errorProcess(error, transactionId, previousResults);\n    }\n  }\n\n  private afterExecute(result: ResultData, localLog: TransactionLog[]) {\n    if (this.state == NodeState.Abort) {\n      return;\n    }\n    this.updateState(NodeState.Completed);\n    this.result = this.getResult(result);\n    if (this.output) {\n      this.result = resultsOf(this.output, { self: this }, this.graph.propFunctions, true);\n      if (this.passThrough) {\n        this.result = { ...this.result, ...this.graph.resultsOf(this.passThrough) };\n      }\n    }\n    this.log.onComplete(this, this.graph, localLog);\n\n    this.onSetResult();\n\n    this.graph.onExecutionComplete(this);\n  }\n\n  // This private method (called only by execute()) prepares the ComputedNode object\n  // for execution, and create a new transaction to record it.\n  private prepareExecute(transactionId: number, inputs: Array<ResultData>) {\n    this.updateState(NodeState.Executing);\n    this.log.beforeExecute(this, this.graph, transactionId, inputs);\n    this.transactionId = transactionId;\n  }\n\n  // This private method (called only by execute) processes an error received from\n  // the agent function. It records the error in the transaction log and handles\n  // the retry if specified.\n  private errorProcess(error: unknown, transactionId: number, namedInputs: DefaultInputData) {\n    if (error instanceof Error && error.message !== strIntentionalError) {\n      GraphAILogger.error(`<-- NodeId: ${this.nodeId}, Agent: ${this.agentId}`);\n      GraphAILogger.error({ namedInputs });\n      GraphAILogger.error(error);\n      GraphAILogger.error(\"-->\");\n    }\n    if (!this.isCurrentTransaction(transactionId)) {\n      GraphAILogger.warn(`-- transactionId mismatch with ${this.nodeId} (not timeout)`);\n      return;\n    }\n\n    if (error instanceof Error) {\n      this.retry(NodeState.Failed, error);\n    } else {\n      GraphAILogger.error(`-- NodeId: ${this.nodeId}: Unknown error was caught`);\n      this.retry(NodeState.Failed, Error(\"Unknown\"));\n    }\n  }\n\n  private getContext(previousResults: Record<string, ResultData | undefined>, localLog: TransactionLog[], agentId?: string, config?: ConfigData) {\n    // Pass debugInfo by reference, and the state of this node will be received by agent/agentFilter.\n    // From graphAgent(nested, map), set the instance of graphai, and use abort on the child graphai.\n    this.debugInfo = this.getDebugInfo(agentId);\n    const params = {\n      ...(this.params ?? {}),\n      ...(isNamedInputs(previousResults?.params) ? previousResults?.params : {}),\n    };\n    const context: AgentFunctionContext<DefaultParamsType, DefaultInputData | string | number | boolean | undefined> = {\n      //params: this.graph.resultsOf(this.params),\n      params,\n      namedInputs: previousResults,\n      inputSchema: this.agentFunction ? undefined : this.graph.getAgentFunctionInfo(agentId)?.inputs,\n      debugInfo: this.debugInfo,\n      cacheType: this.agentFunction ? undefined : this.graph.getAgentFunctionInfo(agentId)?.cacheType,\n      filterParams: this.filterParams,\n      config,\n      log: localLog,\n    };\n    return context;\n  }\n\n  private getResult(result: ResultData) {\n    if (result && this.passThrough) {\n      if (isObject(result) && !Array.isArray(result)) {\n        return { ...result, ...this.graph.resultsOf(this.passThrough) };\n      } else if (Array.isArray(result)) {\n        return result.map((r) => (isObject(r) && !Array.isArray(r) ? { ...r, ...this.graph.resultsOf(this.passThrough) } : r));\n      }\n    }\n    return result;\n  }\n\n  private getDebugInfo(agentId?: string) {\n    return {\n      nodeId: this.nodeId,\n      agentId,\n      retry: this.retryCount,\n      state: this.state,\n      subGraphs: new Map(),\n      verbose: this.graph.verbose,\n      version: this.graph.version,\n      isResult: this.isResult,\n    };\n  }\n\n  private beforeConsoleLog(context: AgentFunctionContext<DefaultParamsType, string | number | boolean | DefaultInputData | undefined>) {\n    if (this.console === false) {\n      return;\n    } else if (this.console === true || this.console.before === true) {\n      GraphAILogger.log(JSON.stringify(context.namedInputs, null, 2));\n    } else if (this.console.before) {\n      GraphAILogger.log(this.console.before);\n    }\n  }\n}\n\nexport class StaticNode extends Node {\n  public value?: ResultData;\n  public readonly update?: DataSource;\n  public readonly isResult: boolean;\n  public readonly isStaticNode = true;\n  public readonly isComputedNode = false;\n\n  constructor(nodeId: string, data: StaticNodeData, graph: GraphAI) {\n    super(nodeId, graph);\n    this.value = data.value;\n    this.update = data.update ? parseNodeName(data.update) : undefined;\n    this.isResult = data.isResult ?? false;\n    this.console = data.console ?? {};\n  }\n\n  public updateValue(value: ResultData, injectFrom?: string) {\n    this.value = value;\n    this.log.onInjected(this, this.graph, injectFrom);\n  }\n  public setResultValue(injectFrom?: string) {\n    this.state = NodeState.Injected;\n    this.result = this.value;\n    this.log.onInjected(this, this.graph, injectFrom);\n    this.onSetResult();\n  }\n\n  public consoleLog() {\n    this.afterConsoleLog(this.result);\n  }\n}\n\nexport type GraphNodes = Record<string, ComputedNode | StaticNode>;\n","export const graphDataAttributeKeys = [\"nodes\", \"concurrency\", \"agentId\", \"loop\", \"verbose\", \"version\", \"metadata\"];\n\nexport const computedNodeAttributeKeys = [\n  \"inputs\",\n  \"output\",\n  \"anyInput\",\n  \"params\",\n  \"retry\",\n  \"repeatUntil\",\n  \"timeout\",\n  \"agent\",\n  \"graph\",\n  \"graphLoader\",\n  \"isResult\",\n  \"priority\",\n  \"if\",\n  \"unless\",\n  \"defaultValue\",\n  \"filterParams\",\n  \"console\",\n  \"passThrough\",\n];\nexport const staticNodeAttributeKeys = [\"value\", \"update\", \"isResult\", \"console\"];\n\nexport class ValidationError extends Error {\n  constructor(message: string) {\n    super(`\\x1b[41m${message}\\x1b[0m`); // Pass the message to the base Error class\n\n    // Set the prototype explicitly to ensure correct prototype chain\n    Object.setPrototypeOf(this, ValidationError.prototype);\n  }\n}\n","import { GraphData } from \"../type\";\nimport { graphDataAttributeKeys, ValidationError } from \"./common\";\n\nexport const graphNodesValidator = (data: GraphData) => {\n  if (data.nodes === undefined) {\n    throw new ValidationError(\"Invalid Graph Data: no nodes\");\n  }\n  if (typeof data.nodes !== \"object\") {\n    throw new ValidationError(\"Invalid Graph Data: invalid nodes\");\n  }\n  if (Array.isArray(data.nodes)) {\n    throw new ValidationError(\"Invalid Graph Data: nodes must be object\");\n  }\n  if (Object.keys(data.nodes).length === 0) {\n    throw new ValidationError(\"Invalid Graph Data: nodes is empty\");\n  }\n  Object.keys(data).forEach((key) => {\n    if (!graphDataAttributeKeys.includes(key)) {\n      throw new ValidationError(\"Graph Data does not allow \" + key);\n    }\n  });\n};\nexport const graphDataValidator = (data: GraphData) => {\n  if (data.loop) {\n    if (data.loop.count === undefined && data.loop.while === undefined) {\n      throw new ValidationError(\"Loop: Either count or while is required in loop\");\n    }\n    if (data.loop.count !== undefined && data.loop.while !== undefined) {\n      throw new ValidationError(\"Loop: Both count and while cannot be set\");\n    }\n  }\n  if (data.concurrency !== undefined) {\n    if (!Number.isInteger(data.concurrency)) {\n      throw new ValidationError(\"Concurrency must be an integer\");\n    }\n    if (data.concurrency < 1) {\n      throw new ValidationError(\"Concurrency must be a positive integer\");\n    }\n  }\n};\n","import { GraphData, AgentFunctionInfoDictionary } from \"./type\";\nimport { isStaticNodeData } from \"./utils/utils\";\nimport { graphNodesValidator, graphDataValidator } from \"./validators/graph_data_validator\";\nimport { nodeValidator } from \"./validators/nodeValidator\";\nimport { staticNodeValidator } from \"./validators/static_node_validator\";\nimport { computedNodeValidator } from \"./validators/computed_node_validator\";\nimport { relationValidator } from \"./validators/relation_validator\";\nimport { agentValidator } from \"./validators/agent_validator\";\n\nimport { ValidationError } from \"./validators/common\";\n\nexport const validateGraphData = (data: GraphData, agentIds: string[]) => {\n  graphNodesValidator(data);\n  graphDataValidator(data);\n  const computedNodeIds: string[] = [];\n  const staticNodeIds: string[] = [];\n  const graphAgentIds = new Set<string>();\n  Object.keys(data.nodes).forEach((nodeId) => {\n    const node = data.nodes[nodeId];\n    const isStaticNode = isStaticNodeData(node);\n    nodeValidator(node);\n    const agentId = isStaticNode ? \"\" : node.agent;\n    isStaticNode && staticNodeValidator(node) && staticNodeIds.push(nodeId);\n    !isStaticNode && computedNodeValidator(node) && computedNodeIds.push(nodeId) && typeof agentId === \"string\" && graphAgentIds.add(agentId);\n  });\n  agentValidator(graphAgentIds, new Set<string>(agentIds));\n  relationValidator(data, staticNodeIds, computedNodeIds);\n\n  return true;\n};\n\nexport const validateAgent = (agentFunctionInfoDictionary: AgentFunctionInfoDictionary) => {\n  Object.keys(agentFunctionInfoDictionary).forEach((agentId: string) => {\n    if (agentId !== \"default\") {\n      const agentInfo = agentFunctionInfoDictionary[agentId];\n      if (!agentInfo || !agentInfo.agent) {\n        throw new ValidationError(\"No Agent: \" + agentId + \" is not in AgentFunctionInfoDictionary.\");\n      }\n    }\n  });\n};\n","import { NodeData, StaticNodeData, ComputedNodeData } from \"../type\";\nimport { ValidationError } from \"./common\";\n\nexport const nodeValidator = (nodeData: NodeData) => {\n  if ((nodeData as ComputedNodeData).agent && (nodeData as StaticNodeData).value) {\n    throw new ValidationError(\"Cannot set both agent and value\");\n  }\n  // if (!(\"agent\" in nodeData) && !(\"value\" in nodeData)) {\n  //   throw new ValidationError(\"Either agent or value is required\");\n  // }\n  return true;\n};\n","import { StaticNodeData } from \"../type\";\nimport { staticNodeAttributeKeys, ValidationError } from \"./common\";\n\nexport const staticNodeValidator = (nodeData: StaticNodeData) => {\n  Object.keys(nodeData).forEach((key) => {\n    if (!staticNodeAttributeKeys.includes(key)) {\n      throw new ValidationError(\"Static node does not allow \" + key);\n    }\n  });\n  return true;\n};\n","import { ComputedNodeData } from \"../type\";\nimport { computedNodeAttributeKeys, ValidationError } from \"./common\";\n\nexport const computedNodeValidator = (nodeData: ComputedNodeData) => {\n  Object.keys(nodeData).forEach((key) => {\n    if (!computedNodeAttributeKeys.includes(key)) {\n      throw new ValidationError(\"Computed node does not allow \" + key);\n    }\n  });\n  return true;\n};\n","import { ValidationError } from \"./common\";\n\nexport const agentValidator = (graphAgentIds: Set<string>, agentIds: Set<string>) => {\n  graphAgentIds.forEach((agentId) => {\n    // agentId or dynamic agentId\n    if (!agentIds.has(agentId) && agentId[0] !== \":\") {\n      throw new ValidationError(\"Invalid Agent : \" + agentId + \" is not in AgentFunctionInfoDictionary.\");\n    }\n  });\n  return true;\n};\n","import { GraphData } from \"../type\";\nimport { parseNodeName, isComputedNodeData, isStaticNodeData } from \"../utils/utils\";\nimport { inputs2dataSources, dataSourceNodeIds } from \"../utils/nodeUtils\";\nimport { ValidationError } from \"./common\";\n\nexport const relationValidator = (graphData: GraphData, staticNodeIds: string[], computedNodeIds: string[]) => {\n  const nodeIds = new Set<string>(Object.keys(graphData.nodes));\n\n  const pendings: Record<string, Set<string>> = {};\n  const waitlist: Record<string, Set<string>> = {};\n\n  // validate input relation and set pendings and wait list\n  computedNodeIds.forEach((computedNodeId) => {\n    const nodeData = graphData.nodes[computedNodeId];\n    pendings[computedNodeId] = new Set<string>();\n\n    const dataSourceValidator = (sourceType: string, sourceNodeIds: string[]) => {\n      sourceNodeIds.forEach((sourceNodeId) => {\n        if (sourceNodeId) {\n          if (!nodeIds.has(sourceNodeId)) {\n            throw new ValidationError(`${sourceType} not match: NodeId ${computedNodeId}, Inputs: ${sourceNodeId}`);\n          }\n          waitlist[sourceNodeId] === undefined && (waitlist[sourceNodeId] = new Set<string>());\n          pendings[computedNodeId].add(sourceNodeId);\n          waitlist[sourceNodeId].add(computedNodeId);\n        }\n      });\n    };\n    if (nodeData && isComputedNodeData(nodeData)) {\n      if (nodeData.inputs) {\n        const sourceNodeIds = dataSourceNodeIds(inputs2dataSources(nodeData.inputs));\n        dataSourceValidator(\"Inputs\", sourceNodeIds);\n      }\n      /*\n      if (nodeData.params) {\n        const sourceNodeIds = dataSourceNodeIds(inputs2dataSources(nodeData.params));\n        dataSourceValidator(\"Params\", sourceNodeIds);\n      }\n      */\n      if (nodeData.if) {\n        const sourceNodeIds = dataSourceNodeIds(inputs2dataSources({ if: nodeData.if }));\n        dataSourceValidator(\"If\", sourceNodeIds);\n      }\n      if (nodeData.unless) {\n        const sourceNodeIds = dataSourceNodeIds(inputs2dataSources({ unless: nodeData.unless }));\n        dataSourceValidator(\"Unless\", sourceNodeIds);\n      }\n      if (nodeData.graph && typeof nodeData?.graph === \"string\") {\n        const sourceNodeIds = dataSourceNodeIds(inputs2dataSources({ graph: nodeData.graph }));\n        dataSourceValidator(\"Graph\", sourceNodeIds);\n      }\n      if (typeof nodeData.agent === \"string\" && nodeData.agent[0] === \":\") {\n        const sourceNodeIds = dataSourceNodeIds(inputs2dataSources({ agent: nodeData.agent }));\n        dataSourceValidator(\"Agent\", sourceNodeIds);\n      }\n    }\n  });\n\n  // TODO. validate update\n  staticNodeIds.forEach((staticNodeId) => {\n    const nodeData = graphData.nodes[staticNodeId];\n    if (isStaticNodeData(nodeData) && nodeData.update) {\n      const update = nodeData.update;\n      const updateNodeId = parseNodeName(update).nodeId;\n      if (!updateNodeId) {\n        throw new ValidationError(\"Update it a literal\");\n      }\n      if (!nodeIds.has(updateNodeId)) {\n        throw new ValidationError(`Update not match: NodeId ${staticNodeId}, update: ${update}`);\n      }\n    }\n  });\n\n  const cycle = (possibles: string[]) => {\n    possibles.forEach((possobleNodeId) => {\n      (waitlist[possobleNodeId] || []).forEach((waitingNodeId) => {\n        pendings[waitingNodeId].delete(possobleNodeId);\n      });\n    });\n\n    const running: string[] = [];\n    Object.keys(pendings).forEach((pendingNodeId) => {\n      if (pendings[pendingNodeId].size === 0) {\n        running.push(pendingNodeId);\n        delete pendings[pendingNodeId];\n      }\n    });\n    return running;\n  };\n\n  let runningQueue = cycle(staticNodeIds);\n  if (runningQueue.length === 0) {\n    throw new ValidationError(\"No Initial Runnning Node\");\n  }\n\n  do {\n    runningQueue = cycle(runningQueue);\n  } while (runningQueue.length > 0);\n\n  if (Object.keys(pendings).length > 0) {\n    throw new ValidationError(\"Some nodes are not executed: \" + Object.keys(pendings).join(\", \"));\n  }\n};\n","import { ComputedNode } from \"./node\";\nimport { assert } from \"./utils/utils\";\n\ntype TaskEntry = {\n  node: ComputedNode;\n  graphId: string;\n  callback: (node: ComputedNode) => void;\n};\n\n// TaskManage object controls the concurrency of ComputedNode execution.\n//\n// NOTE: A TaskManager instance will be shared between parent graph and its children\n// when nested agents are involved.\nexport class TaskManager {\n  private concurrency: number;\n  private taskQueue: Array<TaskEntry> = [];\n  private runningNodes = new Set<ComputedNode>();\n\n  constructor(concurrency: number) {\n    this.concurrency = concurrency;\n  }\n\n  // This internal method dequeus a task from the task queue\n  // and call the associated callback method, if the number of\n  // running task is lower than the spcified limit.\n  private dequeueTaskIfPossible() {\n    if (this.runningNodes.size < this.concurrency) {\n      const task = this.taskQueue.shift();\n      if (task) {\n        this.runningNodes.add(task.node);\n        task.callback(task.node);\n      }\n    }\n  }\n\n  // Node will call this method to put itself in the execution queue.\n  // We call the associated callback function when it is dequeued.\n  public addTask(node: ComputedNode, graphId: string, callback: (node: ComputedNode) => void) {\n    // Finder tasks in the queue, which has either the same or higher priority.\n    const count = this.taskQueue.filter((task) => {\n      return task.node.priority >= node.priority;\n    }).length;\n    assert(count <= this.taskQueue.length, \"TaskManager.addTask: Something is really wrong.\");\n    this.taskQueue.splice(count, 0, { node, graphId, callback });\n    this.dequeueTaskIfPossible();\n  }\n\n  public isRunning(graphId: string) {\n    const count = [...this.runningNodes].filter((node) => {\n      return node.graphId == graphId;\n    }).length;\n    return count > 0 || Array.from(this.taskQueue).filter((data) => data.graphId === graphId).length > 0;\n  }\n\n  // Node MUST call this method once the execution of agent function is completed\n  // either successfully or not.\n  public onComplete(node: ComputedNode) {\n    assert(this.runningNodes.has(node), `TaskManager.onComplete node(${node.nodeId}) is not in list`);\n    this.runningNodes.delete(node);\n    this.dequeueTaskIfPossible();\n  }\n\n  // Node will call this method before it hands the task manager from the graph\n  // to a nested agent. We need to make it sure that there is enough room to run\n  // computed nodes inside the nested graph to avoid a deadlock.\n  public prepareForNesting() {\n    this.concurrency++;\n  }\n\n  public restoreAfterNesting() {\n    this.concurrency--;\n  }\n\n  public getStatus(verbose: boolean = false) {\n    const runningNodes = Array.from(this.runningNodes).map((node) => node.nodeId);\n    const queuedNodes = this.taskQueue.map((task) => task.node.nodeId);\n    const nodes = verbose ? { runningNodes, queuedNodes } : {};\n    return {\n      concurrency: this.concurrency,\n      queue: this.taskQueue.length,\n      running: this.runningNodes.size,\n      ...nodes,\n    };\n  }\n\n  public reset() {\n    this.taskQueue.length = 0;\n    this.runningNodes.clear();\n  }\n}\n","import {\n  AgentFunctionInfoDictionary,\n  AgentFilterInfo,\n  GraphData,\n  DataSource,\n  LoopData,\n  ResultDataDictionary,\n  ResultData,\n  DefaultResultData,\n  GraphOptions,\n  PropFunction,\n  GraphDataLoader,\n  ConfigDataDictionary,\n  CallbackFunction,\n} from \"./type\";\nimport { TransactionLog } from \"./transaction_log\";\n\nimport { ComputedNode, StaticNode, GraphNodes } from \"./node\";\n\nimport { resultsOf, resultOf, cleanResult } from \"./utils/result\";\nimport { propFunctions } from \"./utils/prop_function\";\nimport { parseNodeName, assert, isLogicallyTrue, isComputedNodeData, loopCounterKey } from \"./utils/utils\";\nimport { getDataFromSource } from \"./utils/data_source\";\n\nimport { validateGraphData, validateAgent } from \"./validator\";\nimport { TaskManager } from \"./task_manager\";\nimport { GraphAILogger } from \"./utils/GraphAILogger\";\n\nexport const defaultConcurrency = 8;\nexport const graphDataLatestVersion = 0.5;\n\nexport class GraphAI {\n  public readonly version: number;\n  public readonly graphId: string;\n  private readonly graphData: GraphData;\n  private staticNodeInitData: Record<string, ResultData> = {};\n  private loop?: LoopData;\n  private readonly forceLoop: boolean;\n  private readonly logs: Array<TransactionLog> = [];\n  public readonly mapIndex?: number;\n  public readonly bypassAgentIds: string[];\n  public readonly config?: ConfigDataDictionary = {};\n  public readonly agentFunctionInfoDictionary: AgentFunctionInfoDictionary;\n  public readonly taskManager: TaskManager;\n  public readonly agentFilters: AgentFilterInfo[];\n  public readonly retryLimit?: number;\n  public readonly propFunctions: PropFunction[];\n  public readonly graphLoader?: GraphDataLoader;\n\n  public nodes: GraphNodes;\n  public onLogCallback: CallbackFunction = (__log: TransactionLog, __isUpdate: boolean) => {};\n  public callbacks: CallbackFunction[] = [];\n  public verbose: boolean; // REVIEW: Do we need this?\n\n  private onComplete: (isAbort: boolean) => void;\n  private repeatCount = 0;\n\n  // This method is called when either the GraphAI obect was created,\n  // or we are about to start n-th iteration (n>2).\n  private createNodes(graphData: GraphData) {\n    const nodes = Object.keys(graphData.nodes).reduce((_nodes: GraphNodes, nodeId: string) => {\n      const nodeData = graphData.nodes[nodeId];\n      if (isComputedNodeData(nodeData)) {\n        _nodes[nodeId] = new ComputedNode(this.graphId, nodeId, nodeData, this);\n      } else {\n        const updateValue = this.staticNodeInitData[nodeId];\n        _nodes[nodeId] = new StaticNode(nodeId, updateValue !== undefined ? { ...nodeData, value: updateValue } : nodeData, this);\n      }\n      return _nodes;\n    }, {});\n\n    // Generate the waitlist for each node.\n    Object.keys(nodes).forEach((nodeId) => {\n      const node = nodes[nodeId];\n      if (node.isComputedNode) {\n        node.pendings.forEach((pending) => {\n          if (nodes[pending]) {\n            nodes[pending].waitlist.add(nodeId); // previousNode\n          } else {\n            throw new Error(`createNode: invalid input ${pending} for node, ${nodeId}`);\n          }\n        });\n      }\n    });\n    return nodes;\n  }\n\n  private getValueFromResults(source: DataSource, results: ResultDataDictionary<DefaultResultData>) {\n    return getDataFromSource(source.nodeId ? results[source.nodeId] : undefined, source, this.propFunctions);\n  }\n\n  // for static\n  private setStaticNodeResults(enableConsoleLog: boolean = false) {\n    // If the result property is specified, inject it.\n    // If the previousResults exists (indicating we are in a loop),\n    // process the update property (nodeId or nodeId.propId).\n    Object.keys(this.graphData.nodes).forEach((nodeId) => {\n      const node = this.nodes[nodeId];\n      if (node?.isStaticNode) {\n        const value = node?.value;\n        if (value !== undefined) {\n          node.setResultValue(nodeId);\n        }\n        if (enableConsoleLog) {\n          node.consoleLog();\n        }\n      }\n    });\n  }\n\n  private updateStaticNodes(previousResults?: ResultDataDictionary<DefaultResultData>, enableConsoleLog: boolean = false) {\n    // If the result property is specified, inject it.\n    // If the previousResults exists (indicating we are in a loop),\n    // process the update property (nodeId or nodeId.propId).\n    Object.keys(this.graphData.nodes).forEach((nodeId) => {\n      const node = this.nodes[nodeId];\n      if (node?.isStaticNode) {\n        const update = node?.update;\n        if (update && previousResults) {\n          const result = this.getValueFromResults(update, previousResults);\n          this.updateStaticNodeValue(nodeId, result, update.nodeId);\n        }\n        if (enableConsoleLog) {\n          node.consoleLog();\n        }\n      }\n    });\n  }\n\n  constructor(\n    graphData: GraphData,\n    agentFunctionInfoDictionary: AgentFunctionInfoDictionary,\n    options: GraphOptions = {\n      taskManager: undefined,\n      agentFilters: [],\n      bypassAgentIds: [],\n      config: {},\n      graphLoader: undefined,\n      forceLoop: false,\n      mapIndex: undefined,\n    },\n  ) {\n    if (!graphData.version && !options.taskManager) {\n      GraphAILogger.warn(\"------------ missing version number\");\n    }\n    this.version = graphData.version ?? graphDataLatestVersion;\n    if (this.version < graphDataLatestVersion) {\n      GraphAILogger.warn(`------------ upgrade to ${graphDataLatestVersion}!`);\n    }\n    this.retryLimit = graphData.retry; // optional\n    this.graphId = `${Date.now().toString(36)}-${Math.random().toString(36).substr(2, 9)}`; // URL.createObjectURL(new Blob()).slice(-36);\n    this.agentFunctionInfoDictionary = agentFunctionInfoDictionary;\n    this.propFunctions = propFunctions;\n    this.taskManager = options.taskManager ?? new TaskManager(graphData.concurrency ?? defaultConcurrency);\n    this.agentFilters = options.agentFilters ?? [];\n    this.bypassAgentIds = options.bypassAgentIds ?? [];\n    this.config = options.config;\n    this.graphLoader = options.graphLoader;\n    this.forceLoop = options.forceLoop ?? false;\n    this.mapIndex = options.mapIndex;\n    this.loop = graphData.loop;\n    this.verbose = graphData.verbose === true;\n    this.onComplete = (__isAbort: boolean) => {\n      throw new Error(\"SOMETHING IS WRONG: onComplete is called without run()\");\n    };\n\n    validateGraphData(graphData, [...Object.keys(agentFunctionInfoDictionary), ...this.bypassAgentIds]);\n    validateAgent(agentFunctionInfoDictionary);\n\n    this.graphData = {\n      ...graphData,\n      nodes: {\n        ...graphData.nodes,\n        [loopCounterKey]: { value: 0, update: `:${loopCounterKey}.add(1)` },\n      },\n    };\n    this.nodes = this.createNodes(this.graphData);\n  }\n\n  public getAgentFunctionInfo(agentId?: string) {\n    if (agentId && this.agentFunctionInfoDictionary[agentId]) {\n      return this.agentFunctionInfoDictionary[agentId];\n    }\n    if (agentId && this.bypassAgentIds.includes(agentId)) {\n      return {\n        agent: async () => {\n          return null;\n        },\n        hasGraphData: false,\n        inputs: null,\n        cacheType: undefined, // for node.getContext\n      };\n    }\n    // We are not supposed to hit this error because the validator will catch it.\n    throw new Error(\"No agent: \" + agentId);\n  }\n\n  public asString() {\n    return Object.values(this.nodes)\n      .map((node) => node.asString())\n      .join(\"\\n\");\n  }\n\n  // Public API\n  public results<T = DefaultResultData>(all: boolean, internalUse: boolean = false): ResultDataDictionary<T> {\n    return Object.keys(this.nodes)\n      .filter((nodeId) => (all && (internalUse || nodeId !== loopCounterKey)) || this.nodes[nodeId].isResult)\n      .reduce((results: ResultDataDictionary<T>, nodeId) => {\n        const node = this.nodes[nodeId];\n        if (node.result !== undefined) {\n          results[nodeId] = node.result as T;\n        }\n        return results;\n      }, {});\n  }\n\n  // Public API\n  public errors(): Record<string, Error> {\n    return Object.keys(this.nodes).reduce((errors: Record<string, Error>, nodeId) => {\n      const node = this.nodes[nodeId];\n      if (node.isComputedNode) {\n        if (node.error !== undefined) {\n          errors[nodeId] = node.error;\n        }\n      }\n      return errors;\n    }, {});\n  }\n\n  private pushReadyNodesIntoQueue() {\n    // Nodes without pending data should run immediately.\n    Object.keys(this.nodes).forEach((nodeId) => {\n      const node = this.nodes[nodeId];\n      if (node.isComputedNode) {\n        this.pushQueueIfReady(node);\n      }\n    });\n  }\n\n  private pushQueueIfReady(node: ComputedNode) {\n    if (node.isReadyNode()) {\n      this.pushQueue(node);\n    }\n  }\n\n  public pushQueueIfReadyAndRunning(node: ComputedNode) {\n    if (this.isRunning()) {\n      this.pushQueueIfReady(node);\n    }\n  }\n\n  // for computed\n  public pushQueue(node: ComputedNode) {\n    node.beforeAddTask();\n\n    this.taskManager.addTask(node, this.graphId, (_node) => {\n      assert(node.nodeId === _node.nodeId, \"GraphAI.pushQueue node mismatch\");\n      node.execute();\n    });\n  }\n\n  // Public API\n  public async run<T = DefaultResultData>(all: boolean = false): Promise<ResultDataDictionary<T>> {\n    this.setStaticNodeResults();\n\n    const invalidStaticNodes = Object.values(this.nodes)\n      .filter((node) => node.isStaticNode)\n      .filter((node) => node.result === undefined && node.update === undefined);\n\n    if (invalidStaticNodes.length > 0) {\n      const nodeIds = invalidStaticNodes.map((node) => node.nodeId).join(\", \");\n      throw new Error(`Static node(s) must have value. Set value, injectValue, or set update. Affected nodeIds: ${nodeIds}`);\n    }\n    if (this.isRunning()) {\n      throw new Error(\"This GraphAI instance is already running\");\n    }\n\n    this.pushReadyNodesIntoQueue();\n\n    if (!this.isRunning()) {\n      GraphAILogger.warn(\"-- nothing to execute\");\n      return {};\n    }\n\n    return new Promise((resolve, reject) => {\n      this.onComplete = (isAbort: boolean = false) => {\n        const errors = this.errors();\n        const errorNodeIds = Object.keys(errors);\n        if (errorNodeIds.length > 0 || isAbort) {\n          reject(errors[errorNodeIds[0]]);\n        } else {\n          resolve(this.results(all));\n        }\n      };\n    });\n  }\n\n  public abort(isChild = false) {\n    if (this.isRunning()) {\n      this.resetPending();\n      // Stop All Running node.\n    }\n    // For an agent like an event agent, where an external promise remains unresolved,\n    // aborting and then retrying can cause nodes or the graph to execute again.\n    // To prevent this, the transactionId is updated to ensure the retry fails.\n    Object.values(this.nodes).forEach((node) => node.isComputedNode && (node.transactionId = undefined));\n    if (!isChild) {\n      this.taskManager.reset();\n    }\n    this.onComplete(this.isRunning());\n  }\n  public resetPending() {\n    Object.values(this.nodes).map((node) => {\n      if (node.isComputedNode) {\n        node.resetPending();\n      }\n    });\n  }\n\n  // Public only for testing\n  public isRunning() {\n    return this.taskManager.isRunning(this.graphId);\n  }\n\n  // callback from execute\n  public onExecutionComplete(node: ComputedNode) {\n    this.taskManager.onComplete(node);\n    if (this.isRunning() || this.processLoopIfNecessary()) {\n      return; // continue running\n    }\n    if (this.verbose) {\n      const notExecutedNodes = Object.values(this.nodes).filter((node) => node.isComputedNode && node.state !== \"completed\");\n      if (notExecutedNodes.length > 0) {\n        console.log(\"Those nodes are not running. \" + notExecutedNodes.map((node) => `${node.nodeId}: ${node.state}`).join(\", \"));\n      }\n    }\n\n    this.onComplete(false); // Nothing to run. Finish it.\n  }\n\n  // Must be called only from onExecutionComplete righ after removeRunning\n  // Check if there is any running computed nodes.\n  // In case of no running computed note, start the another iteration if ncessary (loop)\n  private processLoopIfNecessary() {\n    //\n    if (!this.forceLoop && Object.keys(this.errors()).length > 0) {\n      return false;\n    }\n\n    this.repeatCount++;\n    const loop = this.loop;\n    if (!loop) {\n      return false;\n    }\n\n    // We need to update static nodes, before checking the condition\n    const previousResults = this.results(true, true); // results from previous loop\n    this.updateStaticNodes(previousResults);\n    this.setStaticNodeResults();\n\n    if (loop.count === undefined || this.repeatCount < loop.count) {\n      if (loop.while) {\n        const source = parseNodeName(loop.while);\n        const value = this.getValueFromResults(source, this.results(true, true));\n        // NOTE: We treat an empty array as false.\n        if (!isLogicallyTrue(value)) {\n          return false; // while condition is not met\n        }\n      }\n      this.nodes = this.createNodes(this.graphData);\n      this.updateStaticNodes(previousResults, true);\n      this.setStaticNodeResults();\n\n      this.pushReadyNodesIntoQueue();\n      return true; // Indicating that we are going to continue.\n    }\n    return false;\n  }\n\n  public initializeGraphAI() {\n    if (this.isRunning()) {\n      throw new Error(\"This GraphAI instance is running\");\n    }\n    this.nodes = this.createNodes(this.graphData);\n    this.setStaticNodeResults();\n  }\n  public setPreviousResults(previousResults: ResultDataDictionary<DefaultResultData>) {\n    this.updateStaticNodes(previousResults);\n  }\n  public setLoopLog(log: TransactionLog) {\n    log.isLoop = !!this.loop;\n    log.repeatCount = this.repeatCount;\n  }\n\n  public appendLog(log: TransactionLog) {\n    this.logs.push(log);\n    this.onLogCallback(log, false);\n    this.callbacks.forEach((callback) => callback(log, false));\n  }\n\n  public updateLog(log: TransactionLog) {\n    this.onLogCallback(log, true);\n    this.callbacks.forEach((callback) => callback(log, false));\n  }\n\n  public registerCallback(callback: CallbackFunction) {\n    this.callbacks.push(callback);\n  }\n\n  public clearCallbacks() {\n    this.callbacks = [];\n  }\n\n  // Public API\n  public transactionLogs() {\n    return this.logs;\n  }\n\n  // Public API\n  public injectValue(nodeId: string, value: ResultData, injectFrom?: string): void {\n    this.staticNodeInitData[nodeId] = value;\n    this.updateStaticNodeValue(nodeId, value, injectFrom);\n  }\n  public setLoopCount(count: number): void {\n    this.loop = {\n      count,\n    };\n  }\n  private updateStaticNodeValue(nodeId: string, value: ResultData, injectFrom?: string): void {\n    const node = this.nodes[nodeId];\n    if (node && node.isStaticNode) {\n      node.updateValue(value, injectFrom);\n    } else {\n      throw new Error(`injectValue with Invalid nodeId, ${nodeId}`);\n    }\n  }\n  public resultsOf(inputs?: Record<string, any>, anyInput: boolean = false) {\n    const results = resultsOf(inputs ?? {}, this.nodes, this.propFunctions);\n    if (anyInput) {\n      return cleanResult(results);\n    }\n    return results;\n  }\n  public resultOf(source: DataSource) {\n    return resultOf(source, this.nodes, this.propFunctions);\n  }\n}\n"],"names":["NodeState","enabledLevels","debug","info","log","warn","error","customLogger","output","level","args","console","GraphAILogger","setLevelEnabled","enabled","setLogger","logger","propFunctionRegex","propFunctions","result","propId","Array","isArray","length","flat","JSON","stringify","reduce","a","b","Math","max","min","matchJoin","match","join","isObject","Object","keys","values","parse","ret","Number","isNaN","trim","toLowerCase","toUpperCase","equalMatch","sliceMatch","undefined","slice","splitMatch","split","isFinite","String","regex","utilsFunctions","input","nodes","Date","now","floor","loopCounterKey","parseNodeName","inputNodeId","isSelfNode","nodeId","propIds","value","parts","regexUtil","matchUtil","assert","condition","message","isWarn","Error","x","isNull","data","strIntentionalError","defaultAgentInfo","name","samples","inputs","params","description","category","author","repository","license","objectToKeyArray","innerData","forEach","key","push","tmp","debugResultKey","agentId","debugResultKeyInner","map","objectKeys","from","index","isLogicallyTrue","defaultTestContext","debugInfo","retry","verbose","state","Executing","subGraphs","Map","filterParams","agents","isNamedInputs","namedInputs","isComputedNodeData","node","isStaticNodeData","inputs2dataSources","inp","templateMatch","matchAll","m","dataSourceNodeIds","sources","filter","source","TransactionLog","constructor","mapIndex","this","Waiting","initForComputedNode","graph","getAgentId","appendLog","onInjected","injectFrom","isUpdating","endTime","setLoopLog","updateLog","onComplete","localLog","resultKeys","beforeExecute","transactionId","retryCount","startTime","dataSources","inputsData","beforeAddTask","onError","errorMessage","onSkipped","innerGetDataFromSource","propFunction","parseInt","getNestedData","getDataFromSource","resultsOfInner","resultsOf","godResults","text","startsWith","utilsFuncResult","replaceAll","replaceTemplatePlaceholders","resultOf","cleanResultInner","results","Node","waitlist","Set","asString","onSetResult","waitingNodeId","waitingNode","isComputedNode","removePending","pushQueueIfReadyAndRunning","afterConsoleLog","after","self","ComputedNode","graphId","super","isSkip","isStaticNode","passThrough","retryLimit","repeatUntil","timeout","isResult","priority","includes","agent","agentFunction","async","anyInput","pendings","nestedGraph","addPendingNode","graphLoader","if","ifSource","unless","unlessSource","defaultValue","getConfig","hasGraphData","config","add","updateState","resetPending","clear","Abort","abort","isReadyNode","size","Skipped","execute","onExecutionComplete","checkDataAvailability","some","Queued","delete","isCurrentTransaction","executeTimeout","TimedOut","shouldApplyAgentFilter","agentFilter","agentIds","nodeIds","agentFilterHandler","context","next","innerContext","agentFilters","afterExecute","previousResults","hasNestedGraph","Boolean","getAgentFunctionInfo","prepareExecute","setTimeout","getContext","taskManager","prepareForNesting","forNestedGraph","graphData","version","agentFunctionInfoDictionary","graphOptions","bypassAgentIds","onLogCallback","callbacks","beforeConsoleLog","restoreAfterNesting","exists","dummyResult","getResult","repeatResult","Failed","errorProcess","Completed","getDebugInfo","inputSchema","cacheType","r","before","StaticNode","update","updateValue","setResultValue","Injected","consoleLog","graphDataAttributeKeys","computedNodeAttributeKeys","staticNodeAttributeKeys","ValidationError","setPrototypeOf","prototype","validateGraphData","graphNodesValidator","loop","count","while","concurrency","isInteger","graphDataValidator","computedNodeIds","staticNodeIds","graphAgentIds","nodeData","nodeValidator","computedNodeValidator","has","agentValidator","computedNodeId","dataSourceValidator","sourceType","sourceNodeIds","sourceNodeId","staticNodeId","updateNodeId","cycle","possibles","possobleNodeId","running","pendingNodeId","runningQueue","relationValidator","TaskManager","taskQueue","runningNodes","dequeueTaskIfPossible","task","shift","callback","addTask","splice","isRunning","getStatus","queuedNodes","queue","reset","graphDataLatestVersion","createNodes","_nodes","staticNodeInitData","pending","getValueFromResults","setStaticNodeResults","enableConsoleLog","updateStaticNodes","updateStaticNodeValue","options","forceLoop","logs","__log","__isUpdate","repeatCount","toString","random","substr","__isAbort","agentInfo","validateAgent","all","internalUse","errors","pushReadyNodesIntoQueue","pushQueueIfReady","pushQueue","_node","run","invalidStaticNodes","Promise","resolve","reject","isAbort","errorNodeIds","isChild","processLoopIfNecessary","notExecutedNodes","initializeGraphAI","setPreviousResults","isLoop","registerCallback","clearCallbacks","transactionLogs","injectValue","setLoopCount","cleanResult","mock","milliseconds"],"mappings":"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"}