{"version":3,"file":"bundle.umd.js","sources":["../src/filters/namedinput_validator.ts","../src/filters/http_client.ts","../src/filters/cache.ts","../src/filters/step_runner_generator.ts","../src/filters/console_step_runner.ts","../src/utils/runner.ts"],"sourcesContent":["import { AgentFilterFunction } from \"graphai\";\nimport Ajv from \"ajv\";\n\n// export for test\nexport const agentInputValidator = (inputSchema: any, namedInputs: any, nodeId: string, agentId: string | undefined) => {\n  const ajv = new Ajv();\n  const validateSchema = ajv.compile(inputSchema);\n  if (!validateSchema(namedInputs)) {\n    // console.log(validateSchema.errors);\n    throw new Error(`${nodeId}(${agentId ?? \"func\"}) schema not matched`);\n  }\n  return true;\n};\n\nexport const namedInputValidatorFilter: AgentFilterFunction = async (context, next) => {\n  const { inputSchema, namedInputs } = context;\n  const { agentId, nodeId } = context.debugInfo;\n\n  if (inputSchema) {\n    if (inputSchema.type !== \"array\") {\n      agentInputValidator(inputSchema, namedInputs || {}, nodeId, agentId);\n    }\n  }\n\n  return next(context);\n};\n","import { AgentFilterFunction, AgentFunctionContext, isObject } from \"graphai\";\n\nasync function* streamChatCompletion(url: string, postData: AgentFunctionContext, userHeaders: any) {\n  const { params, namedInputs, debugInfo, filterParams } = postData;\n  const postBody = { params, debugInfo, filterParams, namedInputs };\n  const headers = { ...userHeaders, \"Content-Type\": \"text/event-stream\" };\n\n  const completion = await fetch(url, {\n    headers,\n    method: \"POST\",\n    body: JSON.stringify(postBody),\n  });\n\n  const reader = completion.body?.getReader();\n\n  if (completion.status !== 200 || !reader) {\n    throw new Error(\"Request failed\");\n  }\n\n  const decoder = new TextDecoder(\"utf-8\");\n  let done = false;\n  while (!done) {\n    const { done: readDone, value } = await reader.read();\n    if (readDone) {\n      done = readDone;\n      reader.releaseLock();\n    } else {\n      const token = decoder.decode(value, { stream: true });\n      yield token;\n    }\n  }\n}\n\nconst streamingRequest = async (context: AgentFunctionContext, url: string, postData: AgentFunctionContext, userHeaders: any, isDebug: boolean | undefined) => {\n  const generator = streamChatCompletion(url, postData, userHeaders);\n\n  const messages = [];\n  for await (const token of generator) {\n    if (isDebug) {\n      console.log(token);\n    }\n    // callback to stream filter\n    if (token) {\n      messages.push(token);\n      if (messages.join(\"\").indexOf(\"___END___\") === -1 && context.filterParams.streamTokenCallback) {\n        context.filterParams.streamTokenCallback(token);\n      }\n    }\n  }\n\n  const payload_data = messages.join(\"\").split(\"___END___\")[1];\n  const data = JSON.parse(payload_data);\n  return data;\n};\nconst httpRequest = async (url: string, postData: AgentFunctionContext, userHeaders: any) => {\n  const headers = { ...userHeaders, \"Content-Type\": \"application/json\" };\n  const response = await fetch(url, {\n    method: \"post\",\n    headers,\n    body: JSON.stringify(postData),\n  });\n  return await response.json();\n};\n\nexport const httpAgentFilter: AgentFilterFunction = async (context, next) => {\n  const { params, debugInfo, filterParams, namedInputs, config } = context;\n\n  if (filterParams?.server) {\n    const { baseUrl, isDebug, serverAgentUrlDictionary } = filterParams.server;\n    const headers = config?.headers ?? {};\n    if (!isObject(headers)) {\n      throw new Error(\"httpAgentFilter: headers is not object.\");\n    }\n    const agentId = debugInfo.agentId;\n    const isStreaming = filterParams.streamTokenCallback !== undefined;\n    const url = serverAgentUrlDictionary && agentId && serverAgentUrlDictionary[agentId] ? serverAgentUrlDictionary[agentId] : [baseUrl, agentId].join(\"/\");\n    if (url === undefined) {\n      console.log(\"httpAgentFilter: Url is not defined\");\n    }\n    const postData = {\n      params,\n      debugInfo,\n      filterParams,\n      namedInputs,\n      inputs: namedInputs, // alias.\n    };\n    if (isStreaming) {\n      return await streamingRequest(context, url, postData, headers, isDebug);\n    }\n    return await httpRequest(url, postData, headers);\n  }\n  return next(context);\n};\n","import { AgentFilterFunction, AgentFunctionContext, isObject } from \"graphai\";\nimport { sha256 } from \"@noble/hashes/sha2\";\n\ntype CacheAgentFilterSetCache = (key: string, data: any) => Promise<void>;\ntype CacheAgentFilterGetCache = (key: string) => Promise<any>;\ntype CacheAgentFilterGetCacheKey = (context: AgentFunctionContext) => string;\n\n// for cache key, sort object key\nexport const sortObjectKeys = (data: any[] | Record<string, any> | string | number | boolean): any => {\n  if (Array.isArray(data)) {\n    return data.map((d) => sortObjectKeys(d));\n  }\n  if (isObject(data)) {\n    return Object.keys(data)\n      .sort()\n      .reduce((tmp: Record<string, any>, key: string) => {\n        tmp[key] = data[key];\n        return tmp;\n      }, {});\n  }\n  return data;\n};\n\nconst getDefaultCacheKey = (context: AgentFunctionContext) => {\n  const { namedInputs, params, debugInfo } = context;\n  const { agentId } = debugInfo;\n  const cacheKeySeed = sha256(JSON.stringify(sortObjectKeys({ namedInputs, params, agentId })));\n  const cacheKey = btoa(String.fromCharCode(...cacheKeySeed));\n  return cacheKey;\n};\n\n// There are two types of cache\n//  - pureAgent whose results are always the same for each input\n//  - impureAgent with different results for the same inputs. For example, reading a file.\n// pureAgent performs caching within agent filter. impureAgent with different results for the same inputs. For example, reading a file.\n// impureAgent implements a cache mechanism on the agent side.\n// Actual cache reading/writing function is given to cacheAgentFilterGenerator\n\nexport const cacheAgentFilterGenerator = (cacheRepository: {\n  setCache: CacheAgentFilterSetCache;\n  getCache: CacheAgentFilterGetCache;\n  getCacheKey?: CacheAgentFilterGetCacheKey;\n}) => {\n  const { getCache, setCache, getCacheKey } = cacheRepository;\n  const cacheAgentFilter: AgentFilterFunction = async (context, next) => {\n    if (context.cacheType === \"pureAgent\" || context.cacheType === undefined) {\n      const cacheKey = getCacheKey ? getCacheKey(context) : getDefaultCacheKey(context);\n      const cache = await getCache(cacheKey);\n      if (cache) {\n        return cache;\n      }\n      const result = await next(context);\n      await setCache(cacheKey, result);\n      return result;\n    }\n\n    if (context.cacheType === \"impureAgent\") {\n      context.filterParams.cache = {\n        getCache,\n        setCache,\n        getCacheKey: getDefaultCacheKey,\n      };\n    }\n    return next(context);\n  };\n  return cacheAgentFilter;\n};\n","import type { AgentFunctionContext, AgentFilterFunction } from \"graphai\";\n\nexport type StepRunnerAwaitFunction = (context: AgentFunctionContext, result: unknown) => Promise<void>;\n\nexport const stepRunnerGenerator = (awaitStep: StepRunnerAwaitFunction) => {\n  const stepRunnerFilter: AgentFilterFunction = async (context, next) => {\n    const result = await next(context);\n    await awaitStep(context, result);\n    return result;\n  };\n  return stepRunnerFilter;\n};\n","import input from \"@inquirer/input\";\n\nimport { stepRunnerGenerator, StepRunnerAwaitFunction } from \"./step_runner_generator\";\n\nconst awaitStep: StepRunnerAwaitFunction = async (context, result) => {\n  const { params, namedInputs, debugInfo } = context;\n  const { nodeId, agentId, retry, state } = debugInfo;\n  console.log({ nodeId, agentId, params, namedInputs, result, state, retry });\n\n  const message = \"Puress enter to next\";\n  await input({ message: message ?? \"Next\" });\n};\n\nexport const consoleStepRunner = stepRunnerGenerator(awaitStep);\n","import { AgentFunctionContext, AgentFunction, AgentFilterInfo, ResultData } from \"graphai\";\n\n// for test and server.\nexport const agentFilterRunnerBuilder = (__agentFilters: AgentFilterInfo[]) => {\n  const agentFilters = __agentFilters;\n  const agentFilterRunner = (context: AgentFunctionContext, agent: AgentFunction) => {\n    let index = 0;\n\n    const next = (context: AgentFunctionContext): Promise<ResultData> => {\n      const agentFilter = agentFilters[index++];\n      if (agentFilter) {\n        return agentFilter.agent(context, next);\n      }\n      return agent(context);\n    };\n\n    return next(context);\n  };\n  return agentFilterRunner;\n};\n"],"names":["agentInputValidator","inputSchema","namedInputs","nodeId","agentId","Ajv","compile","validateSchema","Error","streamingRequest","async","context","url","postData","userHeaders","isDebug","generator","params","debugInfo","filterParams","postBody","headers","completion","fetch","method","body","JSON","stringify","reader","getReader","status","decoder","TextDecoder","done","readDone","value","read","releaseLock","token","decode","stream","streamChatCompletion","messages","console","log","push","join","indexOf","streamTokenCallback","payload_data","split","parse","sortObjectKeys","data","Array","isArray","map","d","isObject","Object","keys","sort","reduce","tmp","key","getDefaultCacheKey","cacheKeySeed","sha256","btoa","String","fromCharCode","stepRunnerGenerator","awaitStep","next","result","consoleStepRunner","retry","state","input","message","__agentFilters","agentFilters","agent","index","agentFilter","cacheRepository","getCache","setCache","getCacheKey","cacheType","undefined","cacheKey","cache","config","server","baseUrl","serverAgentUrlDictionary","isStreaming","inputs","response","json","httpRequest","type"],"mappings":"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"}