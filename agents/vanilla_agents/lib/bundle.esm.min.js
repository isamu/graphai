import{assert as e,isObject as t,graphDataLatestVersion as a,GraphAI as r,sleep as s}from"graphai";import{arrayValidate as n,isNamedInputs as o}from"@graphai/agent_utils";const p=async({params:t,namedInputs:a})=>{e(!!a,"stringSplitterAgent: namedInputs is UNDEFINED!");const r=a.text,s=t.chunkSize??2048,n=t.overlap??Math.floor(s/8),o=Math.floor(r.length/(s-n))+1;return{contents:new Array(o).fill(void 0).map(((e,t)=>{const a=t*(s-n);return r.substring(a,a+s)})),count:o,chunkSize:s,overlap:n}},i={name:"stringSplitterAgent",agent:p,mock:p,inputs:{type:"object",properties:{text:{type:"string",description:"text to be chuncked"}},required:["text"]},output:{type:"object",properties:{contents:{type:"array",description:"the array of text chunks"},count:{type:"number",description:"the number of chunks"},chunkSize:{type:"number",description:"the chunk size"},overlap:{type:"number",description:"the overlap size"}}},samples:[{inputs:{text:"Here's to the crazy ones, the misfits, the rebels, the troublemakers, the round pegs in the square holes ... the ones who see things differently -- they're not fond of rules, and they have no respect for the status quo. ... You can quote them, disagree with them, glorify or vilify them, but the only thing you can't do is ignore them because they change things. ... They push the human race forward, and while some may see them as the crazy ones, we see genius, because the people who are crazy enough to think that they can change the world, are the ones who do."},params:{chunkSize:64},result:{contents:["Here's to the crazy ones, the misfits, the rebels, the troublema","roublemakers, the round pegs in the square holes ... the ones wh"," ones who see things differently -- they're not fond of rules, a","rules, and they have no respect for the status quo. ... You can ","You can quote them, disagree with them, glorify or vilify them, ","y them, but the only thing you can't do is ignore them because t","ecause they change things. ... They push the human race forward,","forward, and while some may see them as the crazy ones, we see g","we see genius, because the people who are crazy enough to think ","o think that they can change the world, are the ones who do."," do."],count:11,chunkSize:64,overlap:8}}],description:"This agent strip one long string into chunks using following parameters",category:["string"],author:"Satoshi Nakajima",repository:"https://github.com/receptron/graphai",source:"https://github.com/receptron/graphai/blob/main/agents/vanilla_agents/src/string_agents/string_splitter_agent.ts",package:"@graphai/vanilla",license:"MIT"},l=(e,a,r)=>"string"==typeof e?e===a?r:e.replace(a,r):Array.isArray(e)?e.map((e=>l(e,a,r))):t(e)?Object.keys(e).reduce(((t,s)=>(t[s]=l(e[s],a,r),t)),{}):e,u=async({params:e,namedInputs:t})=>{if(void 0===e.template){if(t.text)return t.text;console.warn("warning: stringTemplateAgent no template")}return Object.keys(t).reduce(((e,a)=>l(e,"${"+a+"}",t[a])),e.template)},m={message1:"hello",message2:"test"},c={name:"stringTemplateAgent",agent:u,mock:u,inputs:{type:"object",description:"Key-value pairs where each key corresponds to a variable used in the template (e.g., ${key}).",additionalProperties:{type:["string","number","boolean","object","array","null"],description:"Any value to be substituted into the template. Objects and arrays are injected directly if the entire field is a placeholder."}},params:{type:"object",description:"The template to apply substitutions to. Supports strings, arrays, and deeply nested object structures with placeholder strings.",properties:{template:{description:"The template structure where placeholders like ${key} will be replaced with values from 'inputs'.",anyOf:[{type:"string"},{type:"array",items:{anyOf:[{type:"string"},{type:"object",additionalProperties:{anyOf:[{type:"string"},{type:"array",items:{type:"string"}}]}}]}},{type:"object",additionalProperties:{anyOf:[{type:"string"},{type:"array",items:{type:"string"}},{type:"object",additionalProperties:!0}]}}]}},required:["template"],additionalProperties:!1},output:{description:"The result after placeholder substitution, matching the structure and type of the original template.",anyOf:[{type:"string"},{type:"array",items:{anyOf:[{type:"string"},{type:"object",additionalProperties:!0}]}},{type:"object",additionalProperties:!0}]},samples:[{inputs:m,params:{template:"${message1}: ${message2}"},result:"hello: test"},{inputs:m,params:{template:["${message1}: ${message2}","${message2}: ${message1}"]},result:["hello: test","test: hello"]},{inputs:m,params:{template:{apple:"${message1}",lemon:"${message2}"}},result:{apple:"hello",lemon:"test"}},{inputs:m,params:{template:[{apple:"${message1}",lemon:"${message2}"}]},result:[{apple:"hello",lemon:"test"}]},{inputs:m,params:{template:{apple:"${message1}",lemon:["${message2}"]}},result:{apple:"hello",lemon:["test"]}},{inputs:{agent:"openAiAgent",row:"hello world",params:{text:"message"}},params:{template:{version:.5,nodes:{ai:{agent:"${agent}",isResult:!0,params:"${params}",inputs:{prompt:"${row}"}}}}},result:{nodes:{ai:{agent:"openAiAgent",inputs:{prompt:"hello world"},isResult:!0,params:{text:"message"}}},version:.5}}],description:"Template agent",category:["string"],author:"Satoshi Nakajima",repository:"https://github.com/receptron/graphai",source:"https://github.com/receptron/graphai/blob/main/agents/vanilla_agents/src/string_agents/string_template_agent.ts",package:"@graphai/vanilla",cacheType:"pureAgent",license:"MIT"},g=async({namedInputs:e})=>{const{text:t,data:a}=e;if(a)return{text:JSON.stringify(a,null,2)};const r=("\n"+t).match(/\n```[a-zA-Z]*([\s\S]*?)\n```/);return r?{data:JSON.parse(r[1])}:{data:JSON.parse(t??"")}},d={apple:"red",lemon:"yellow"},y=JSON.stringify(d),h=["```",y,"```"].join("\n"),b=["```json",y,"```"].join("\n"),f=["```JSON",y,"```"].join("\n"),v={name:"jsonParserAgent",agent:g,mock:g,inputs:{type:"object",description:"The input object containing either a JSON string in 'text' or a raw JavaScript object in 'data'. One of them is required.",properties:{text:{type:"string",description:"A JSON string, possibly embedded in a Markdown code block. If provided, it will be parsed into a data object."},data:{anyOf:[{type:"object"},{type:"array"},{type:"string"},{type:"number"}],description:"Raw data to be converted into a formatted JSON string in the 'text' output."}},required:[],additionalProperties:!1},params:{type:"object",description:"No parameters are required for this agent.",properties:{},additionalProperties:!1},output:{type:"object",description:"Returns either a parsed data object (from 'text') or a formatted JSON string (from 'data').",properties:{text:{type:"string",description:"A pretty-printed JSON string generated from the 'data' input, if provided."},data:{anyOf:[{type:"object"},{type:"array"},{type:"string"},{type:"number"}],description:"Parsed data object from the 'text' input, or the original 'data' if no parsing was required."}},required:[],additionalProperties:!1},samples:[{inputs:{data:d},params:{},result:{text:JSON.stringify(d,null,2)}},{inputs:{text:JSON.stringify(d,null,2)},params:{},result:{data:d}},{inputs:{text:h},params:{},result:{data:d}},{inputs:{text:b},params:{},result:{data:d}},{inputs:{text:f},params:{},result:{data:d}}],description:"Template agent",category:["string"],author:"Satoshi Nakajima",repository:"https://github.com/receptron/graphai",source:"https://github.com/receptron/graphai/blob/main/agents/vanilla_agents/src/string_agents/json_parser_agent.ts",package:"@graphai/vanilla",license:"MIT"},w=async({namedInputs:e,params:t})=>{const{suffix:a}=t,r=e.text.trim().replace(/[\s-_]+/g," ").toLowerCase().split(" ");a&&r[r.length-1]!==a&&r.push(a);const s=r.join(" ");return{lowerCamelCase:r.map(((e,t)=>0===t?e:e.charAt(0).toUpperCase()+e.slice(1))).join(""),snakeCase:s.replace(/\s+/g,"_"),kebabCase:s.replace(/\s+/g,"-"),normalized:s}},A={name:"stringCaseVariantsAgent",agent:w,mock:w,inputs:{type:"object",properties:{text:{type:"string",description:"The input string to be transformed into various casing styles."}},required:["text"],additionalProperties:!1},params:{type:"object",properties:{suffix:{type:"string",description:"An optional suffix to append to the input string before transforming cases."}},additionalProperties:!1},output:{type:"object",properties:{kebabCase:{type:"string",description:"The input string converted to kebab-case (e.g., 'this-is-a-pen')."},snakeCase:{type:"string",description:"The input string converted to snake_case (e.g., 'this_is_a_pen')."},lowerCamelCase:{type:"string",description:"The input string converted to lowerCamelCase (e.g., 'thisIsAPen')."},normalized:{type:"string",description:"The original string, optionally appended with the suffix, in lowercase with normalized spacing."}},required:["kebabCase","snakeCase","lowerCamelCase","normalized"],additionalProperties:!1},samples:[{inputs:{text:"this is a pen"},params:{},result:{kebabCase:"this-is-a-pen",lowerCamelCase:"thisIsAPen",normalized:"this is a pen",snakeCase:"this_is_a_pen"}},{inputs:{text:"string case variants"},params:{suffix:"agent"},result:{kebabCase:"string-case-variants-agent",lowerCamelCase:"stringCaseVariantsAgent",normalized:"string case variants agent",snakeCase:"string_case_variants_agent"}}],description:"Format String Cases agent",category:["string"],author:"Receptron team",repository:"https://github.com/receptron/graphai",source:"https://github.com/receptron/graphai/blob/main/agents/vanilla_agents/src/string_agents/string_case_variants_agent.ts",package:"@graphai/vanilla",license:"MIT"},T=(t,s)=>async n=>{const{namedInputs:o,log:p,debugInfo:i,params:l,forNestedGraph:u}=n;e(!!u,"Please update graphai to 0.5.19 or higher");const{agents:m,graphOptions:c,onLogCallback:g,callbacks:d}=u,{taskManager:y}=c,h=l.supressError??!1;if(y){const t=y.getStatus(!1);e(t.concurrency>t.running,`nestedAgent: Concurrency is too low: ${t.concurrency}`)}e(!!t,"nestedAgent: graph is required");const{nodes:b}=t,f=Object.keys(b).reduce(((e,t)=>{const a=b[t];if("agent"in a)e[t]=a;else{const{value:r,update:s,isResult:n,console:o}=a;e[t]={value:r,update:s,isResult:n,console:o}}return e}),{}),v={...t,nodes:f,version:a},w=Object.keys(o);w.length>0&&w.forEach((e=>{void 0===v.nodes[e]?v.nodes[e]={value:o[e]}:void 0!==o[e]&&(v.nodes[e].value=o[e])}));try{void 0===v.version&&i.version&&(v.version=i.version);const e=new r(v,m||{},c);g&&(e.onLogCallback=g),d&&(e.callbacks=d),i.subGraphs.set(e.graphId,e);const t=await e.run(!1);return i.subGraphs.delete(e.graphId),p?.push(...e.transactionLogs()),s&&s.resultNodeId?t[s.resultNodeId]:t}catch(e){if(e instanceof Error&&h)return{onError:{message:e.message,error:e}};throw e}},j=async t=>{const{forNestedGraph:a,params:r}=t,{graphData:s}=a??{graphData:{nodes:{}}};return e(!!s,"No GraphData"),await T(s,r)(t)},I={name:"nestedAgent",agent:j,mock:j,samples:[{inputs:{message:"hello"},params:{},result:{test:["hello"]},graph:{nodes:{test:{agent:"copyAgent",params:{namedKey:"messages"},inputs:{messages:[":message"]},isResult:!0}}}},{inputs:{message:"hello"},params:{resultNodeId:"test"},result:["hello"],graph:{nodes:{test:{agent:"copyAgent",params:{namedKey:"messages"},inputs:{messages:[":message"]},isResult:!0}}}}],description:"nested Agent",category:["graph"],author:"Receptron team",repository:"https://github.com/receptron/graphai",source:"https://github.com/receptron/graphai/blob/main/agents/vanilla_agents/src/graph_agents/nested_agent.ts",package:"@graphai/vanilla",license:"MIT"},k=T({version:a,nodes:{newText:{value:""},oldText:{value:""},isNewText:{if:":newText",agent:"copyAgent",inputs:{text:":newText"}},isOldText:{unless:":newText",agent:"copyAgent",inputs:{text:":oldText"}},updatedText:{agent:"copyAgent",anyInput:!0,inputs:{text:[":isNewText.text",":isOldText.text"]}},resultText:{isResult:!0,agent:"copyAgent",anyInput:!0,inputs:{text:":updatedText.text.$0"}}}},{resultNodeId:"resultText"}),_={name:"stringUpdateTextAgent",agent:k,mock:k,inputs:{type:"object",properties:{newText:{type:"string",description:"The new text to use if provided and not empty."},oldText:{type:"string",description:"The fallback text used if 'newText' is empty or not provided."}},additionalProperties:!1},params:{type:"object",description:"No parameters are used in this agent.",properties:{},additionalProperties:!1},output:{type:"object",properties:{text:{type:"string",description:"The resulting text. It is either the value of 'newText' if non-empty, otherwise 'oldText', or an empty string if both are missing."}},required:["text"],additionalProperties:!1},samples:[{inputs:{newText:"new",oldText:"old"},params:{},result:{text:"new"}},{inputs:{newText:"",oldText:"old"},params:{},result:{text:"old"}},{inputs:{},params:{},result:{text:""}},{inputs:{oldText:"old"},params:{},result:{text:"old"}}],description:"",category:[],author:"",repository:"",source:"https://github.com/receptron/graphai/blob/main/agents/vanilla_agents/src/string_agents/string_update_text_agent.ts",package:"@graphai/vanilla",tools:[],license:"",hasGraphData:!0},x=async({namedInputs:e})=>{const{text:t}=e;return console.info(t),{text:t}},P={name:"consoleAgent",agent:x,mock:x,inputs:{type:"object",properties:{text:{type:"string",description:"text"}}},output:{type:"object",properties:{text:{type:"string",description:"text"}}},samples:[{inputs:{text:"hello"},params:{},result:{text:"hello"}}],description:"Just text to console.info",category:["string"],author:"Receptron team",repository:"https://github.com/receptron/graphai",source:"https://github.com/receptron/graphai/blob/main/agents/vanilla_agents/src/string_agents/console_agent.ts",package:"@graphai/vanilla",license:"MIT"},E=async({namedInputs:t})=>{const a=" Set inputs: { array: :arrayNodeId, item: :itemNodeId }";n("pushAgent",t,a);const{item:r,items:s}=t;e(void 0!==r||void 0!==s,"pushAgent: namedInputs.item and namedInputs.items are UNDEFINED!"+a),e(void 0===s||Array.isArray(s),"pushAgent: namedInputs.items is not array!");const o=t.array.map((e=>e));return void 0!==r&&o.push(r),s&&s.forEach((e=>{o.push(e)})),{array:o}},R={name:"pushAgent",agent:E,mock:E,inputs:{type:"object",properties:{array:{type:"array",description:"the array to push an item to"},item:{anyOf:[{type:"string"},{type:"integer"},{type:"object"},{type:"array"},{type:"boolean"}],description:"the item push into the array"},items:{type:"array",description:"items push into the array"}},required:["array"]},output:{type:"object",properties:{array:{type:"array"}}},samples:[{inputs:{array:[1,2],item:3},params:{},result:{array:[1,2,3]}},{inputs:{array:[!0,!1],item:!1},params:{},result:{array:[!0,!1,!1]}},{inputs:{array:[{apple:1}],item:{lemon:2}},params:{},result:{array:[{apple:1},{lemon:2}]}},{inputs:{array:[{apple:1}],items:[{lemon:2},{banana:3}]},params:{},result:{array:[{apple:1},{lemon:2},{banana:3}]}}],description:"push Agent",category:["array"],cacheType:"pureAgent",author:"Receptron team",repository:"https://github.com/receptron/graphai",source:"https://github.com/receptron/graphai/blob/main/agents/vanilla_agents/src/array_agents/push_agent.ts",package:"@graphai/vanilla",license:"MIT"},O=async({namedInputs:e})=>{n("popAgent",e);const t=[...e.array],a=t.pop();return{array:t,item:a}},N={name:"popAgent",agent:O,mock:O,inputs:{type:"object",properties:{array:{type:"array",description:"the array to pop an item from"}},required:["array"]},output:{type:"object",properties:{item:{anyOf:[{type:"string"},{type:"integer"},{type:"object"},{type:"array"}],description:"the item popped from the array"},array:{type:"array",description:"the remaining array"}}},samples:[{inputs:{array:[1,2,3]},params:{},result:{array:[1,2],item:3}},{inputs:{array:["a","b","c"]},params:{},result:{array:["a","b"],item:"c"}},{inputs:{array:[1,2,3],array2:["a","b","c"]},params:{},result:{array:[1,2],item:3}}],description:"Pop Agent",category:["array"],cacheType:"pureAgent",author:"Receptron team",repository:"https://github.com/receptron/graphai",source:"https://github.com/receptron/graphai/blob/main/agents/vanilla_agents/src/array_agents/pop_agent.ts",package:"@graphai/vanilla",license:"MIT"},M=async({namedInputs:e})=>{n("shiftAgent",e);const t=e.array.map((e=>e)),a=t.shift();return{array:t,item:a}},q={name:"shiftAgent",agent:M,mock:M,inputs:{type:"object",properties:{array:{type:"array",description:"the array to shift an item from"}},required:["array"]},output:{type:"object",properties:{item:{anyOf:[{type:"string"},{type:"integer"},{type:"object"},{type:"array"}],description:"the item shifted from the array"},array:{type:"array",description:"the remaining array"}}},samples:[{inputs:{array:[1,2,3]},params:{},result:{array:[2,3],item:1}},{inputs:{array:["a","b","c"]},params:{},result:{array:["b","c"],item:"a"}}],description:"shift Agent",category:["array"],cacheType:"pureAgent",author:"Receptron team",repository:"https://github.com/receptron/graphai",source:"https://github.com/receptron/graphai/blob/main/agents/vanilla_agents/src/array_agents/shift_agent.ts",package:"@graphai/vanilla",license:"MIT"},S=async({namedInputs:e,params:t})=>{n("arrayFlatAgent",e);const a=t.depth??1;return{array:e.array.map((e=>e)).flat(a)}},C={name:"arrayFlatAgent",agent:S,mock:S,inputs:{type:"object",properties:{array:{type:"array",description:"The array to be flattened"}},required:["array"]},output:{type:"object",properties:{array:{type:"array",description:"flattened array"}}},params:{type:"object",properties:{depth:{type:"number",description:"flattening depth"}}},samples:[{inputs:{array:[[1],[2],[3]]},params:{},result:{array:[1,2,3]}},{inputs:{array:[[1],[2],[[3]]]},params:{},result:{array:[1,2,[3]]}},{inputs:{array:[[1],[2],[[3]]]},params:{depth:2},result:{array:[1,2,3]}},{inputs:{array:[["a"],["b"],["c"]]},params:{},result:{array:["a","b","c"]}}],description:"Array Flat Agent",category:["array"],author:"Receptron team",repository:"https://github.com/receptron/graphai",source:"https://github.com/receptron/graphai/blob/main/agents/vanilla_agents/src/array_agents/array_flat_agent.ts",package:"@graphai/vanilla",cacheType:"pureAgent",license:"MIT"},D=async({namedInputs:e,params:t})=>{n("arrayJoinAgent",e);const a=t.separator??"",{flat:r}=t;return{text:r?e.array.flat(r).join(a):e.array.join(a)}},U={name:"arrayJoinAgent",agent:D,mock:D,inputs:{type:"object",properties:{array:{type:"array",description:"array join"}},required:["array"]},params:{type:"object",properties:{separator:{type:"string",description:"array join separator"},flat:{type:"number",description:"array flat depth"}}},output:{type:"object",properties:{text:{type:"string",description:"joined text"}}},samples:[{inputs:{array:[[1],[2],[3]]},params:{},result:{text:"123"}},{inputs:{array:[[1],[2],[[3]]]},params:{},result:{text:"123"}},{inputs:{array:[["a"],["b"],["c"]]},params:{},result:{text:"abc"}},{inputs:{array:[[1],[2],[3]]},params:{separator:"|"},result:{text:"1|2|3"}},{inputs:{array:[[[1]],[[2],[3]]]},params:{separator:"|"},result:{text:"1|2,3"}},{inputs:{array:[[[1]],[[2],[3]]]},params:{separator:"|",flat:1},result:{text:"1|2|3"}},{inputs:{array:[[[[1]],[[2],[3]]]]},params:{separator:"|",flat:1},result:{text:"1|2,3"}},{inputs:{array:[[[[1]],[[2],[3]]]]},params:{separator:"|",flat:2},result:{text:"1|2|3"}}],description:"Array Join Agent",category:["array"],cacheType:"pureAgent",author:"Receptron team",repository:"https://github.com/receptron/graphai",source:"https://github.com/receptron/graphai/blob/main/agents/vanilla_agents/src/array_agents/array_join_agent.ts",package:"@graphai/vanilla",license:"MIT"},V=async({params:t,namedInputs:a})=>{e(o(a),"arrayToObjectAgent: namedInputs is UNDEFINED!");const{items:r}=a,{key:s}=t;return e(void 0!==r&&Array.isArray(r),"arrayToObjectAgent: namedInputs.items is not array!"),e(null!=s,"arrayToObjectAgent: params.key is UNDEFINED!"),a.items.reduce(((e,t)=>(e[t[s]]=t,e)),{})},$={name:"arrayToObjectAgent",agent:V,mock:V,inputs:{type:"object",properties:{items:{type:"array",description:"the array to pop an item from"}},required:["items"]},output:{type:"object",properties:{anyOf:[{type:"string"},{type:"integer"},{type:"object"},{type:"array"}],description:"the item popped from the array"}},samples:[{inputs:{items:[{id:1,data:"a"},{id:2,data:"b"}]},params:{key:"id"},result:{1:{id:1,data:"a"},2:{id:2,data:"b"}}}],description:"Array To Object Agent",category:["array"],cacheType:"pureAgent",author:"Receptron team",repository:"https://github.com/receptron/graphai",source:"https://github.com/receptron/graphai/blob/main/agents/vanilla_agents/src/array_agents/array_to_object.ts",package:"@graphai/vanilla",license:"MIT"},K=async({namedInputs:t})=>{e(!!t,"dotProductAgent: namedInputs is UNDEFINED!");const a=t.matrix,r=t.vector;if(a[0].length!=r.length)throw new Error(`dotProduct: Length of vectors do not match. ${a[0].length}, ${r.length}`);return a.map((e=>e.reduce(((e,t,a)=>e+t*r[a]),0)))},L={name:"dotProductAgent",agent:K,mock:K,inputs:{type:"object",properties:{matrix:{type:"array",description:"A two-dimensional array of numbers. Each inner array represents a vector to be compared.",items:{type:"array",items:{type:"number",description:"A numeric value within a vector."},description:"A vector of numbers (row in the matrix)."}},vector:{type:"array",description:"A single vector of numbers to compute dot products with each vector in the matrix.",items:{type:"number",description:"A numeric component of the target vector."}}},required:["matrix","vector"],additionalProperties:!1},params:{type:"object",description:"No parameters are used in this agent.",properties:{},additionalProperties:!1},output:{type:"array",description:"An array of numbers representing the dot products between each vector in 'matrix' and the input 'vector'.",items:{type:"number",description:"The result of a dot product between a matrix row and the input vector."}},samples:[{inputs:{matrix:[[1,2],[3,4],[5,6]],vector:[3,2]},params:{},result:[7,17,27]},{inputs:{matrix:[[1,2],[2,3]],vector:[1,2]},params:{},result:[5,8]}],description:"dotProduct Agent",category:["matrix"],author:"Receptron team",repository:"https://github.com/receptron/graphai",source:"https://github.com/receptron/graphai/blob/main/agents/vanilla_agents/src/matrix_agents/dot_product_agent.ts",package:"@graphai/vanilla",license:"MIT"},F=async({params:t,namedInputs:a})=>{e(!!a,"sortByValue: namedInputs is UNDEFINED!"),e(!!a.array,"sortByValue: namedInputs.array is UNDEFINED!"),e(!!a.values,"sortByValue: namedInputs.values is UNDEFINED!");const r=t?.assendant?-1:1,s=a.array,n=a.values;return s.map(((e,t)=>({item:e,value:n[t]}))).sort(((e,t)=>(t.value-e.value)*r)).map((e=>e.item))},J={name:"sortByValuesAgent",agent:F,mock:F,inputs:{type:"object",properties:{array:{type:"array",description:"The array of items to be sorted. Each item will be paired with a corresponding numeric value from the 'values' array."},values:{type:"array",description:"An array of numeric values used to determine the sort order of the 'array' items. Must be the same length as 'array'.",items:{type:"number"}}},required:["array","values"],additionalProperties:!1},params:{type:"object",properties:{assendant:{type:"boolean",description:"If true, sorts in ascending order; otherwise, in descending order (default)."}},additionalProperties:!1},output:{type:"array",description:"A new array where items from 'array' are sorted based on their corresponding values in 'values'.",items:{type:"any"}},samples:[{inputs:{array:["banana","orange","lemon","apple"],values:[2,5,6,4]},params:{},result:["lemon","orange","apple","banana"]},{inputs:{array:["banana","orange","lemon","apple"],values:[2,5,6,4]},params:{assendant:!0},result:["banana","apple","orange","lemon"]}],description:"sortByValues Agent",category:["matrix"],author:"Receptron team",repository:"https://github.com/receptron/graphai",source:"https://github.com/receptron/graphai/blob/main/agents/vanilla_agents/src/matrix_agents/sort_by_values_agent.ts",package:"@graphai/vanilla",license:"MIT"},z=async({params:e,filterParams:t})=>e.filterParams?t:e,H={name:"echoAgent",agent:z,mock:z,inputs:{type:"object",description:"This agent does not use inputs. Leave empty.",properties:{},additionalProperties:!1},params:{type:"object",description:"Any parameters you want to echo back. If 'filterParams' is true, only filtered parameters will be returned.",properties:{filterParams:{type:"boolean",description:"If true, returns 'filterParams' instead of the full 'params'."}},additionalProperties:!0},output:{type:"object",description:"Returns the full 'params' object or the 'filterParams' object if 'filterParams' is set to true.",additionalProperties:!0},samples:[{inputs:{},params:{text:"this is test"},result:{text:"this is test"}},{inputs:{},params:{text:"If you add filterParams option, it will respond to filterParams",filterParams:!0},result:{}}],description:"Echo agent",category:["test"],cacheType:"pureAgent",author:"Satoshi Nakajima",repository:"https://github.com/receptron/graphai",source:"https://github.com/receptron/graphai/blob/main/agents/vanilla_agents/src/test_agents/echo_agent.ts",package:"@graphai/vanilla",license:"MIT"},G=async({params:e})=>({list:new Array(e.count).fill(void 0).map(((e,t)=>t))}),X={name:"countingAgent",agent:G,mock:G,inputs:{type:"object",description:"This agent does not require any inputs. Leave empty.",properties:{},additionalProperties:!1},params:{type:"object",description:"Parameter that defines how many numbers to generate, starting from 0.",properties:{count:{type:"integer",minimum:0,description:"The number of integers to generate, starting from 0 up to count - 1."}},required:["count"],additionalProperties:!1},output:{type:"object",description:"An object containing a list of sequential integers.",properties:{list:{type:"array",description:"An array of integers from 0 to count - 1.",items:{type:"integer"}}},required:["list"],additionalProperties:!1},samples:[{inputs:{},params:{count:4},result:{list:[0,1,2,3]}}],description:"Counting agent",category:["test"],cacheType:"pureAgent",author:"Receptron team",repository:"https://github.com/receptron/graphai",source:"https://github.com/receptron/graphai/blob/main/agents/vanilla_agents/src/test_agents/counting_agent.ts",package:"@graphai/vanilla",license:"MIT"},Y=async({params:e})=>({messages:new Array(e.count).fill(void 0).map((()=>e.message))}),B={name:"copyMessageAgent",agent:Y,mock:Y,inputs:{type:"object",description:"This agent does not use any inputs. Leave empty.",properties:{},additionalProperties:!1},params:{type:"object",description:"Parameters to define the message and how many times to repeat it.",properties:{count:{type:"integer",minimum:1,description:"The number of times the message should be duplicated in the array."},message:{type:"string",description:"The message string to be repeated."}},required:["count","message"],additionalProperties:!1},output:{type:"object",description:"An object containing the repeated messages.",properties:{messages:{type:"array",description:"An array of repeated message strings.",items:{type:"string"}}},required:["messages"],additionalProperties:!1},samples:[{inputs:{},params:{count:4,message:"hello"},result:{messages:["hello","hello","hello","hello"]}}],description:"CopyMessage agent",category:["test"],cacheType:"pureAgent",author:"Receptron team",repository:"https://github.com/receptron/graphai",source:"https://github.com/receptron/graphai/blob/main/agents/vanilla_agents/src/test_agents/copy_message_agent.ts",package:"@graphai/vanilla",license:"MIT"},W=async({namedInputs:t,params:a})=>{e(o(t),"copy2ArrayAgent: namedInputs is UNDEFINED!");const r=t.item?t.item:t;return new Array(a.count).fill(void 0).map((()=>r))},Q={name:"copy2ArrayAgent",agent:W,mock:W,inputs:{type:"object",description:"The input item to be duplicated. Can be provided as 'item' or as a free-form object.",properties:{item:{description:"The item to be copied into each element of the resulting array.",anyOf:[{type:"object"},{type:"string"},{type:"number"},{type:"array"},{type:"boolean"}]}},additionalProperties:!0},params:{type:"object",description:"Parameters controlling the number of copies to return.",properties:{count:{type:"integer",description:"The number of times to copy the input item into the output array.",minimum:1}},required:["count"],additionalProperties:!1},output:{type:"array",description:"An array of 'count' copies of the input item.",items:{description:"A duplicated copy of the input item.",anyOf:[{type:"object"},{type:"string"},{type:"number"},{type:"array"},{type:"boolean"}]}},samples:[{inputs:{item:{message:"hello"}},params:{count:10},result:[{message:"hello"},{message:"hello"},{message:"hello"},{message:"hello"},{message:"hello"},{message:"hello"},{message:"hello"},{message:"hello"},{message:"hello"},{message:"hello"}]},{inputs:{message:"hello"},params:{count:10},result:[{message:"hello"},{message:"hello"},{message:"hello"},{message:"hello"},{message:"hello"},{message:"hello"},{message:"hello"},{message:"hello"},{message:"hello"},{message:"hello"}]},{inputs:{item:"hello"},params:{count:10},result:["hello","hello","hello","hello","hello","hello","hello","hello","hello","hello"]}],description:"Copy2Array agent",category:["test"],cacheType:"pureAgent",author:"Receptron team",repository:"https://github.com/receptron/graphai",source:"https://github.com/receptron/graphai/blob/main/agents/vanilla_agents/src/test_agents/copy2array_agent.ts",package:"@graphai/vanilla",license:"MIT"},Z=async({debugInfo:{nodeId:e},namedInputs:t})=>{n("mergeNodeIdAgent",t);return t.array.reduce(((e,t)=>({...e,...t})),{[e]:"hello"})},ee={name:"mergeNodeIdAgent",agent:Z,mock:Z,inputs:{type:"object",properties:{array:{type:"array",description:"An array of objects to be merged together into a single object. Each object represents a partial result or state.",items:{type:"object",description:"A single object containing key-value pairs to merge."}}},required:["array"],additionalProperties:!1},params:{type:"object",description:"This agent does not take any parameters. The object must be empty.",properties:{},additionalProperties:!1},samples:[{inputs:{array:[{message:"hello"}]},params:{},result:{message:"hello",test:"hello"}}],description:"merge node id agent",category:["test"],author:"Receptron team",repository:"https://github.com/receptron/graphai",source:"https://github.com/receptron/graphai/blob/main/agents/vanilla_agents/src/test_agents/merge_node_id_agent.ts",package:"@graphai/vanilla",license:"MIT"},te=async({params:e,filterParams:t,namedInputs:a})=>{const r=e.message??a.message??"";for await(const a of r.split(""))t.streamTokenCallback&&t.streamTokenCallback(a),await s(e.sleep||100);return{message:r}},ae={name:"streamMockAgent",agent:te,mock:te,inputs:{anyOf:[{type:"object",properties:{message:{type:"string",description:"streaming message"}}},{type:"array"}]},samples:[{inputs:{},params:{message:"this is params test"},result:{message:"this is params test"}},{inputs:{message:"this is named inputs test"},params:{},result:{message:"this is named inputs test"}}],description:"Stream mock agent",category:["test"],author:"Isamu Arimoto",repository:"https://github.com/receptron/graphai",source:"https://github.com/receptron/graphai/blob/main/agents/vanilla_agents/src/test_agents/stream_mock_agent.ts",package:"@graphai/vanilla",license:"MIT",stream:!0},re=async({params:t,namedInputs:s,log:n,debugInfo:o,forNestedGraph:p})=>{e(!!p,"Please update graphai to 0.5.19 or higher");const{limit:i,resultAll:l,compositeResult:u,compositeResultKey:m,supressError:c,rowKey:g,expandKeys:d}=t,{agents:y,graphData:h,graphOptions:b,onLogCallback:f,callbacks:v}=p,{taskManager:w}=b;if(w){const t=w.getStatus();e(t.concurrency>t.running,`mapAgent: Concurrency is too low: ${t.concurrency}`)}e(!!s.rows,"mapAgent: rows property is required in namedInput"),e(!!h,"mapAgent: graph is required");const A=s.rows.map((e=>e));i&&i<A.length&&(A.length=i);const T=g??"row",{nodes:j}=h,I={...h,nodes:{...j},version:a},k=Object.keys(s);I.nodes.__mapIndex={},k.forEach((e=>{const t="rows"===e?T:e;void 0===I.nodes[t]?I.nodes[t]={value:s[e]}:"agent"in I.nodes[t]||(I.nodes[t].value=s[e])}));try{void 0===I.version&&o.version&&(I.version=o.version);const e=A.map(((e,t)=>{const a=new r(I,y||{},b);return o.subGraphs.set(a.graphId,a),a.injectValue(T,e,"__mapAgent_inputs__"),a.injectValue("__mapIndex",t,"__mapAgent_inputs__"),d&&d.length>0&&d.map((e=>{a.injectValue(e,s[e]?.[t])})),f&&(a.onLogCallback=f),v&&(a.callbacks=v),a})),t=e.map((e=>e.run(l))),a=await Promise.all(t),p=Object.keys(a[0]);if(e.map((e=>{o.subGraphs.delete(e.graphId)})),n){const t=e.map(((e,t)=>e.transactionLogs().map((e=>(e.mapIndex=t,e)))));n.push(...t.flat())}if(u||m){const e=p.reduce(((e,t)=>(e[t]=a.map((e=>e[t])),e)),{});return m?e[m]:e}return a}catch(e){if(e instanceof Error&&c)return{onError:{message:e.message,error:e}};throw e}},se={name:"mapAgent",agent:re,mock:re,samples:[{inputs:{rows:["apple","orange","banana","lemon"],color:["red","orange","yellow","yellow"]},params:{compositeResult:!0,expandKeys:["color"]},graph:{version:.5,nodes:{node2:{agent:"copyAgent",inputs:{a:":row",b:":color"},isResult:!0}}},result:{node2:[{a:"apple",b:"red"},{a:"orange",b:"orange"},{a:"banana",b:"yellow"},{a:"lemon",b:"yellow"}]}},{inputs:{rows:[1,2]},params:{},result:[{test:[1]},{test:[2]}],graph:{nodes:{test:{agent:"copyAgent",params:{namedKey:"rows"},inputs:{rows:[":row"]},isResult:!0}}}},{inputs:{rows:[1,2]},params:{rowKey:"myKey"},result:[{test:[1]},{test:[2]}],graph:{nodes:{test:{agent:"copyAgent",params:{namedKey:"rows"},inputs:{rows:[":myKey"]},isResult:!0}}}},{inputs:{rows:["apple","orange","banana","lemon","melon","pineapple","tomato"]},params:{},graph:{nodes:{node2:{agent:"stringTemplateAgent",params:{template:"I love ${word}."},inputs:{word:":row"},isResult:!0}}},result:[{node2:"I love apple."},{node2:"I love orange."},{node2:"I love banana."},{node2:"I love lemon."},{node2:"I love melon."},{node2:"I love pineapple."},{node2:"I love tomato."}]},{inputs:{rows:[{fruit:"apple"},{fruit:"orange"}]},params:{},graph:{nodes:{node2:{agent:"stringTemplateAgent",params:{template:"I love ${item}."},inputs:{item:":row.fruit"},isResult:!0}}},result:[{node2:"I love apple."},{node2:"I love orange."}]},{inputs:{rows:[{fruit:"apple"},{fruit:"orange"}],name:"You",verb:"like"},params:{},graph:{nodes:{node2:{agent:"stringTemplateAgent",params:{template:"${name} ${verb} ${fruit}."},inputs:{fruit:":row.fruit",name:":name",verb:":verb"},isResult:!0}}},result:[{node2:"You like apple."},{node2:"You like orange."}]},{inputs:{rows:[1,2]},params:{resultAll:!0},result:[{__mapIndex:0,test:[1],row:1},{__mapIndex:1,test:[2],row:2}],graph:{nodes:{test:{agent:"copyAgent",params:{namedKey:"rows"},inputs:{rows:[":row"]}}}}},{inputs:{rows:[1,2]},params:{resultAll:!0},result:[{__mapIndex:0,map:[{test:1},{test:1}],row:1,test:1},{__mapIndex:1,map:[{test:2},{test:2}],test:2,row:2}],graph:{nodes:{test:{agent:"copyAgent",params:{namedKey:"row"},inputs:{row:":row"}},map:{agent:"mapAgent",inputs:{rows:[":test",":test"]},graph:{nodes:{test:{isResult:!0,agent:"copyAgent",params:{namedKey:"row"},inputs:{row:":row"}}}}}}}},{inputs:{rows:[1,2]},params:{compositeResult:!0},result:{test:[[1],[2]]},graph:{nodes:{test:{agent:"copyAgent",params:{namedKey:"rows"},inputs:{rows:[":row"]},isResult:!0}}}},{inputs:{rows:["apple","orange","banana","lemon","melon","pineapple","tomato"]},params:{compositeResult:!0},graph:{nodes:{node2:{agent:"stringTemplateAgent",params:{template:"I love ${row}."},inputs:{row:":row"},isResult:!0}}},result:{node2:["I love apple.","I love orange.","I love banana.","I love lemon.","I love melon.","I love pineapple.","I love tomato."]}},{inputs:{rows:["apple","orange","banana","lemon","melon","pineapple","tomato"]},params:{compositeResult:!0,compositeResultKey:"node2"},graph:{nodes:{node2:{agent:"stringTemplateAgent",params:{template:"I love ${row}."},inputs:{row:":row"},isResult:!0}}},result:["I love apple.","I love orange.","I love banana.","I love lemon.","I love melon.","I love pineapple.","I love tomato."]},{inputs:{rows:[1,2]},params:{resultAll:!0,compositeResult:!0},result:{test:[[1],[2]],__mapIndex:[0,1],row:[1,2]},graph:{nodes:{test:{agent:"copyAgent",params:{namedKey:"rows"},inputs:{rows:[":row"]}}}}},{inputs:{rows:[1,2]},params:{resultAll:!0,compositeResult:!0},result:{__mapIndex:[0,1],test:[[1],[2]],map:[{test:[[[1]],[[1]]]},{test:[[[2]],[[2]]]}],row:[1,2]},graph:{nodes:{test:{agent:"copyAgent",params:{namedKey:"rows"},inputs:{rows:[":row"]}},map:{agent:"mapAgent",inputs:{rows:[":test",":test"]},params:{compositeResult:!0},graph:{nodes:{test:{isResult:!0,agent:"copyAgent",params:{namedKey:"rows"},inputs:{rows:[":row"]}}}}}}}}],description:"Map Agent",category:["graph"],author:"Receptron team",repository:"https://github.com/receptron/graphai",source:"https://github.com/receptron/graphai/blob/main/agents/vanilla_agents/src/graph_agents/map_agent.ts",package:"@graphai/vanilla",license:"MIT"},ne=async({namedInputs:t,params:a})=>{const{flatResponse:r}=a;e(o(t),"totalAgent: namedInputs is UNDEFINED! Set inputs: { array: :arrayNodeId }"),e(!!t?.array,"totalAgent: namedInputs.array is UNDEFINED! Set inputs: { array: :arrayNodeId }");const s=t.array.reduce(((e,t)=>((Array.isArray(t)?t:[t]).forEach((t=>{Object.keys(t).forEach((a=>{const r=t[a];e[a]?e[a]+=r:e[a]=r}))})),e)),{});return r?s:{data:s}},oe={name:"totalAgent",agent:ne,mock:ne,inputs:{type:"object",properties:{array:{type:"array",description:"An array of objects or arrays of objects. Each inner object must have numeric values which will be aggregated by key.",items:{anyOf:[{type:"object",description:"A flat object containing numeric values to be summed."},{type:"array",items:{type:"object",description:"Nested array of objects, each containing numeric values to be summed."}}]}}},required:["array"],additionalProperties:!1},params:{type:"object",properties:{flatResponse:{type:"boolean",description:"If true, the result will be returned as a plain object (e.g., { a: 6 }); otherwise, wrapped in { data: {...} }."}},additionalProperties:!1},output:{type:"object"},samples:[{inputs:{array:[{a:1},{a:2},{a:3}]},params:{},result:{data:{a:6}}},{inputs:{array:[[{a:1,b:-1},{c:10}],[{a:2,b:-1}],[{a:3,b:-2},{d:-10}]]},params:{},result:{data:{a:6,b:-4,c:10,d:-10}}},{inputs:{array:[{a:1}]},params:{},result:{data:{a:1}}},{inputs:{array:[{a:1},{a:2}]},params:{},result:{data:{a:3}}},{inputs:{array:[{a:1},{a:2},{a:3}]},params:{},result:{data:{a:6}}},{inputs:{array:[{a:1,b:1},{a:2,b:2},{a:3,b:0}]},params:{},result:{data:{a:6,b:3}}},{inputs:{array:[{a:1},{a:2,b:2},{a:3,b:0}]},params:{},result:{data:{a:6,b:2}}},{inputs:{array:[{a:1},{a:2},{a:3}]},params:{flatResponse:!0},result:{a:6}},{inputs:{array:[[{a:1,b:-1},{c:10}],[{a:2,b:-1}],[{a:3,b:-2},{d:-10}]]},params:{flatResponse:!0},result:{a:6,b:-4,c:10,d:-10}},{inputs:{array:[{a:1}]},params:{flatResponse:!0},result:{a:1}},{inputs:{array:[{a:1},{a:2}]},params:{flatResponse:!0},result:{a:3}},{inputs:{array:[{a:1},{a:2},{a:3}]},params:{flatResponse:!0},result:{a:6}},{inputs:{array:[{a:1,b:1},{a:2,b:2},{a:3,b:0}]},params:{flatResponse:!0},result:{a:6,b:3}},{inputs:{array:[{a:1},{a:2,b:2},{a:3,b:0}]},params:{flatResponse:!0},result:{a:6,b:2}}],description:"Returns the sum of input values",category:["data"],author:"Satoshi Nakajima",repository:"https://github.com/snakajima/graphai",source:"https://github.com/receptron/graphai/blob/main/agents/vanilla_agents/src/data_agents/total_agent.ts",package:"@graphai/vanilla",license:"MIT"},pe=async({namedInputs:t,params:a})=>{const{flatResponse:r}=a;e(o(t),"dataSumTemplateAgent: namedInputs is UNDEFINED! Set inputs: { array: :arrayNodeId }"),e(!!t?.array,"dataSumTemplateAgent: namedInputs.array is UNDEFINED! Set inputs: { array: :arrayNodeId }");const s=t.array.reduce(((e,t)=>e+t),0);return r?s:{result:s}},ie={name:"dataSumTemplateAgent",agent:pe,mock:pe,inputs:{type:"object",properties:{array:{type:"array",description:"the array of numbers to calculate the sum of",items:{type:"integer"}}},required:["array"]},output:{type:"number"},samples:[{inputs:{array:[1]},params:{},result:{result:1}},{inputs:{array:[1,2]},params:{},result:{result:3}},{inputs:{array:[1,2,3]},params:{},result:{result:6}},{inputs:{array:[1]},params:{flatResponse:!0},result:1},{inputs:{array:[1,2]},params:{flatResponse:!0},result:3},{inputs:{array:[1,2,3]},params:{flatResponse:!0},result:6}],description:"Returns the sum of input values",category:["data"],author:"Satoshi Nakajima",repository:"https://github.com/receptron/graphai",source:"https://github.com/receptron/graphai/blob/main/agents/vanilla_agents/src/data_agents/data_sum_template_agent.ts",package:"@graphai/vanilla",license:"MIT"},le=(e,t,a,r,s,n,o,p,i)=>{const l=r||Object.keys(e),u=new Set(s??[]),m=l.reduce(((t,a)=>{if(!u.has(a)){const r=n&&n[a];r&&r[e[a]]?t[a]=r[e[a]]:t[a]=e[a]}return t}),{});return o&&o.forEach((e=>{void 0!==e.index&&e.index!==t||(m[e.propId]=a[e.from])})),i&&i.forEach((e=>{const t=a[e.from??1];e.equal?m[e.propId]=e.equal===t:e.notEqual&&(m[e.propId]=e.notEqual!==t)})),p&&Object.keys(p).forEach((e=>{const t=m[e];m[e]=m[p[e]],m[p[e]]=t})),m},ue=async({namedInputs:e,params:t})=>{const{include:a,exclude:r,alter:s,inject:n,swap:o,inspect:p}=t,{array:i,item:l}=e;if(i){const[e]=i;return Array.isArray(e)?e.map(((e,t)=>le(e,t,i,a,r,s,n,o,p))):le(e,0,i,a,r,s,n,o,p)}return!!l&&le(l,0,[],a,r,s,n,o,p)},me={array:[[{color:"red",model:"Model 3",type:"EV",maker:"Tesla",range:300},{color:"blue",model:"Model Y",type:"EV",maker:"Tesla",range:400}],"Tesla Motors"]},ce={name:"propertyFilterAgent",agent:ue,mock:ue,inputs:{type:"object"},output:{type:"any",properties:{array:{type:"array",description:"the array to apply filter"},item:{type:"object",description:"the object to apply filter"}}},samples:[{inputs:{array:[me.array[0][0]]},params:{include:["color","model"]},result:{color:"red",model:"Model 3"}},{inputs:{item:me.array[0][0]},params:{include:["color","model"]},result:{color:"red",model:"Model 3"}},{inputs:me,params:{include:["color","model"]},result:[{color:"red",model:"Model 3"},{color:"blue",model:"Model Y"}]},{inputs:me,params:{exclude:["color","model"]},result:[{type:"EV",maker:"Tesla",range:300},{type:"EV",maker:"Tesla",range:400}]},{inputs:{item:me.array[0][0]},params:{exclude:["color","model"]},result:{type:"EV",maker:"Tesla",range:300}},{inputs:me,params:{alter:{color:{red:"blue",blue:"red"}}},result:[{color:"blue",model:"Model 3",type:"EV",maker:"Tesla",range:300},{color:"red",model:"Model Y",type:"EV",maker:"Tesla",range:400}]},{inputs:{item:me.array[0][0]},params:{alter:{color:{red:"blue",blue:"red"}}},result:{color:"blue",model:"Model 3",type:"EV",maker:"Tesla",range:300}},{inputs:me,params:{swap:{maker:"model"}},result:[{color:"red",model:"Tesla",type:"EV",maker:"Model 3",range:300},{color:"blue",model:"Tesla",type:"EV",maker:"Model Y",range:400}]},{inputs:{item:me.array[0][0]},params:{swap:{maker:"model"}},result:{color:"red",model:"Tesla",type:"EV",maker:"Model 3",range:300}},{inputs:me,params:{inject:[{propId:"maker",from:1}]},result:[{color:"red",model:"Model 3",type:"EV",maker:"Tesla Motors",range:300},{color:"blue",model:"Model Y",type:"EV",maker:"Tesla Motors",range:400}]},{inputs:me,params:{inject:[{propId:"maker",from:1,index:0}]},result:[{color:"red",model:"Model 3",type:"EV",maker:"Tesla Motors",range:300},{color:"blue",model:"Model Y",type:"EV",maker:"Tesla",range:400}]},{inputs:me,params:{inspect:[{propId:"isTesla",equal:"Tesla Motors"},{propId:"isGM",notEqual:"Tesla Motors",from:1}]},result:[{color:"red",model:"Model 3",type:"EV",maker:"Tesla",range:300,isTesla:!0,isGM:!1},{color:"blue",model:"Model Y",type:"EV",maker:"Tesla",range:400,isTesla:!0,isGM:!1}]}],description:"Filter properties based on property name either with 'include', 'exclude', 'alter', 'swap', 'inject', 'inspect'",category:["data"],author:"Receptron team",repository:"https://github.com/receptron/graphai",source:"https://github.com/receptron/graphai/blob/main/agents/vanilla_agents/src/data_agents/property_filter_agent.ts",package:"@graphai/vanilla",license:"MIT"},ge=async({namedInputs:t,params:a})=>{const{namedKey:r}=a;return e(o(t),"copyAgent: namedInputs is UNDEFINED!"),r?t[r]:t},de={name:"copyAgent",agent:ge,mock:ge,inputs:{type:"object",description:"A dynamic object containing any number of named input fields. The agent either returns the whole object or a single value by key.",additionalProperties:{type:["string","number","boolean","object","array","null"],description:"A value associated with a named input key. Can be any JSON-compatible type."}},params:{type:"object",properties:{namedKey:{type:"string",description:"If specified, the agent will return only the value associated with this key from namedInputs."}},additionalProperties:!1},output:{anyOf:[{type:"string"},{type:"integer"},{type:"object"},{type:"array"}]},samples:[{inputs:{color:"red",model:"Model 3"},params:{},result:{color:"red",model:"Model 3"}},{inputs:{array:["Hello World","Discarded"]},params:{},result:{array:["Hello World","Discarded"]}},{inputs:{color:"red",model:"Model 3"},params:{namedKey:"color"},result:"red"}],description:"Returns namedInputs",category:["data"],author:"Receptron team",repository:"https://github.com/receptron/graphai",source:"https://github.com/receptron/graphai/blob/main/agents/vanilla_agents/src/data_agents/copy_agent.ts",package:"@graphai/vanilla",license:"MIT"},ye=async({namedInputs:t,params:a})=>{const{namedKey:r}=t;e(o(t),"lookupDictionaryAgent: namedInputs is UNDEFINED!");const s=a[r];if(!a.supressError&&void 0===s)throw new Error(`lookupDictionaryAgent error: ${r} is missing`);return s},he={openai:{model:"gpt4-o",temperature:.7},groq:{model:"llama3-8b-8192",temperature:.6},gemini:{model:"gemini-2.0-pro-exp-02-05",temperature:.7}},be={name:"lookupDictionaryAgent",agent:ye,mock:ye,inputs:{type:"object",properties:{namedKey:{type:"string",description:"The key to look up in the dictionary provided by 'params'."},supressError:{type:"boolean",description:"If true, prevents the agent from throwing an error when the key is missing in 'params'. Optional."}},required:["namedKey"],additionalProperties:!1},params:{type:"object",description:"A dictionary of values from which one is selected using the 'namedKey'.",additionalProperties:{type:["string","number","boolean","object","array","null"],description:"Any JSON-compatible value associated with a key in the dictionary."}},output:{anyOf:[{type:"string"},{type:"integer"},{type:"object"},{type:"array"}]},samples:[{inputs:{namedKey:"openai"},params:he,result:{model:"gpt4-o",temperature:.7}},{inputs:{namedKey:"gemini"},params:he,result:{model:"gemini-2.0-pro-exp-02-05",temperature:.7}}],description:"Select elements with params",category:["data"],author:"Receptron team",repository:"https://github.com/receptron/graphai",source:"https://github.com/receptron/graphai/blob/main/agents/vanilla_agents/src/data_agents/lookup_dictionary_agent.ts",package:"@graphai/vanilla",license:"MIT"},fe=async({namedInputs:t})=>{e(o(t),"mergeObjectAgent: namedInputs is UNDEFINED!");const{items:a}=t;return e(void 0!==a&&Array.isArray(a),"mergeObjectAgent: namedInputs.items is not array!"),Object.assign({},...a)},ve={name:"mergeObjectAgent",agent:fe,mock:fe,inputs:{type:"object",properties:{items:{type:"array",description:"An array of objects whose key-value pairs will be merged into a single object. Later objects override earlier ones on key conflict.",items:{type:"object",description:"An individual object contributing to the merged result."}}},required:["items"],additionalProperties:!1},params:{type:"object",description:"This agent does not take any parameters. The object must be empty.",properties:{},additionalProperties:!1},output:{anyOf:{type:"object"}},samples:[{inputs:{items:[{color:"red"},{model:"Model 3"}]},params:{},result:{color:"red",model:"Model 3"}}],description:"Returns namedInputs",category:["data"],author:"Receptron team",repository:"https://github.com/receptron/graphai",source:"https://github.com/receptron/graphai/blob/main/agents/vanilla_agents/src/data_agents/merge_objects_agent.ts",package:"@graphai/vanilla",license:"MIT"},we=["GET","HEAD","POST","OPTIONS","PUT","DELETE","PATCH"],Ae=["POST","PUT","PATCH"],Te=async({namedInputs:t,params:a,config:r})=>{const{url:s,method:n,queryParams:o,body:p}={...a,...t};e(!!s,"fetchAgent: no url");const i=a.supressError??!1,l=new URL(s),u={...a.headers?a.headers:{},...t.headers?t.headers:{}};if(r&&r.authorization&&(u.Authorization=r.authorization),o){const e=new URLSearchParams(o);l.search=e.toString()}p&&(u["Content-Type"]="application/json");const m={method:n?n.toUpperCase():p?"POST":"GET",headers:new Headers(u),body:p?JSON.stringify(p):void 0};if(e(we.includes(m.method??""),"fetchAgent: invalid method: "+m.method),e(!Ae.includes(m.method??"")||!!p,"fetchAgent: The request body is required for this method: "+m.method),a?.debug)return{url:l.toString(),method:m.method,headers:u,body:m.body};const c=await fetch(l.toString(),m);if(!c.ok){const e=c.status,t="json"===(a?.type??"json")?await c.json():await c.text();if(i)return{onError:{message:`HTTP error: ${e}`,status:e,error:t}};throw new Error(`HTTP error: ${e}`)}const g=await(async()=>{const e=a?.type??"json";if("json"===e)return await c.json();if("text"===e)return c.text();throw new Error(`Unknown Type! ${e}`)})();return!1===a.flatResponse?{data:g}:g},je={name:"vanillaFetchAgent",agent:Te,mock:Te,inputs:{type:"object",properties:{url:{type:"string",description:"The request URL. Can be provided in either 'inputs' or 'params'."},method:{type:"string",description:"The HTTP method to use (GET, POST, PUT, etc.). Defaults to GET if not specified and no body is provided; otherwise POST."},headers:{type:"object",description:"Optional HTTP headers to include in the request. Values from both inputs and params are merged."},queryParams:{type:"object",description:"Optional query parameters to append to the URL."},body:{description:"Optional request body to send with POST, PUT, or PATCH methods.",anyOf:[{type:"string"},{type:"object"}]}},required:[],additionalProperties:!1},params:{type:"object",properties:{url:{type:"string",description:"The request URL (overridden if also specified in inputs)."},method:{type:"string",description:"The HTTP method (overridden if also specified in inputs)."},headers:{type:"object",description:"Additional headers. Merged with inputs.headers."},queryParams:{type:"object",description:"Query parameters to append to the URL."},body:{description:"Request body to be sent, used with POST/PUT/PATCH.",anyOf:[{type:"string"},{type:"object"}]},debug:{type:"boolean",description:"If true, returns the prepared request details instead of performing the actual fetch."},supressError:{type:"boolean",description:"If true, suppresses thrown errors and returns the error response instead."},flatResponse:{type:"boolean",description:"If true, returns the raw response. If false, wraps the response in an object with a 'data' key. Default is false."},type:{type:"string",enum:["json","text"],description:"Response type to parse. Either 'json' or 'text'. Defaults to 'json'."}},required:[],additionalProperties:!1},output:{description:"Returns either the HTTP response body or a debug object. If an error occurs and 'supressError' is true, returns an object with an 'onError' key.",anyOf:[{type:"object",properties:{onError:{type:"object",properties:{message:{type:"string"},status:{type:"integer"},error:{}},required:["message","status","error"]}},required:["onError"],additionalProperties:!0},{type:"object",description:"Debug information returned when 'debug' is true.",properties:{method:{type:"string"},url:{type:"string"},headers:{type:"object"},body:{}},required:["method","url","headers"]},{},{type:"object",description:"When 'flatResponse' is false, the response is wrapped as { data: ... }.",properties:{data:{}},required:["data"],additionalProperties:!0}]},samples:[{inputs:{url:"https://example.com",queryParams:{foo:"bar"},headers:{"x-myHeader":"secret"}},params:{debug:!0},result:{method:"GET",url:"https://example.com/?foo=bar",headers:{"x-myHeader":"secret"},body:void 0}},{inputs:{url:"https://example.com",body:{foo:"bar"}},params:{debug:!0},result:{method:"POST",url:"https://example.com/",headers:{"Content-Type":"application/json"},body:JSON.stringify({foo:"bar"})}},{inputs:{url:"https://example.com",body:{foo:"bar"},method:"PUT"},params:{debug:!0},result:{method:"PUT",url:"https://example.com/",headers:{"Content-Type":"application/json"},body:JSON.stringify({foo:"bar"})}},{inputs:{url:"https://example.com",method:"options"},params:{debug:!0},result:{method:"OPTIONS",url:"https://example.com/",headers:{},body:void 0}},{inputs:{},params:{url:"https://example.com",body:{foo:"bar"},method:"PUT",debug:!0},result:{method:"PUT",url:"https://example.com/",headers:{"Content-Type":"application/json"},body:JSON.stringify({foo:"bar"})}},{inputs:{method:"DELETE",headers:{authentication:"bearer XXX"}},params:{url:"https://example.com",body:{foo:"bar"},method:"PUT",headers:{"Content-Type":"application/json"},debug:!0},result:{method:"DELETE",url:"https://example.com/",headers:{"Content-Type":"application/json",authentication:"bearer XXX"},body:JSON.stringify({foo:"bar"})}}],description:"Retrieves JSON data from the specified URL",category:["service"],author:"Receptron",repository:"https://github.com/receptron/graphai",source:"https://github.com/receptron/graphai/blob/main/agents/vanilla_agents/src/service_agents/vanilla_fetch_agent.ts",package:"@graphai/vanilla",license:"MIT"},Ie=async({params:e,namedInputs:t})=>(await s(e?.duration??10),t),ke={name:"sleeperAgent",agent:Ie,mock:Ie,inputs:{type:"object",description:"Arbitrary input data. This agent does not modify it and returns it unchanged after a delay.",additionalProperties:!0},params:{type:"object",properties:{duration:{type:"number",description:"Optional duration in milliseconds to pause execution before returning the input. Defaults to 10ms."}},additionalProperties:!1},output:{type:"object",description:"Returns the same object passed as 'inputs', unchanged.",additionalProperties:!0},samples:[{inputs:{},params:{duration:1},result:{}},{inputs:{array:[{a:1},{b:2}]},params:{duration:1},result:{array:[{a:1},{b:2}]}}],description:"sleeper Agent for test and debug",category:["sleeper"],author:"Receptron team",repository:"https://github.com/receptron/graphai",source:"https://github.com/receptron/graphai/blob/main/agents/vanilla_agents/src/sleeper_agents/sleeper_agent.ts",package:"@graphai/vanilla",license:"MIT"},_e=e=>{const t=e.map((e=>Array.isArray(e)?_e(e):e)),[a,r,s]=t;if("=="===r)return a===s;if("!="===r)return a!==s;if(">"===r)return Number(a)>Number(s);if(">="===r)return Number(a)>=Number(s);if("<"===r)return Number(a)<Number(s);if("<="===r)return Number(a)<=Number(s);if("||"===r)return!!a||!!s;if("&&"===r)return!!a&&!!s;if("XOR"===r)return!!a==!s;throw new Error("unknown compare operator")},xe=e=>null==e,Pe=async({namedInputs:e,params:t})=>{const{array:a,leftValue:r,rightValue:s}=e,n=a??[],o=(()=>{if(2===n.length&&t.operator)return[n[0],t.operator,n[1]];if(3===n.length)return n;if(0===n.length&&!xe(r)&&!xe(s)&&t.operator)return[r,t.operator,s];throw new Error("compare inputs is wrong.")})(),p=_e(o);return t?.value?{result:t?.value[p?"true":"false"]??p}:{result:p}},Ee={name:"compareAgent",agent:Pe,mock:Pe,inputs:{type:"object",properties:{array:{type:"array",description:"A 3-element array in the form [leftOperand, operator, rightOperand]. Used for direct comparison logic.",items:{type:["string","number","boolean","array"]}},leftValue:{type:["string","number","boolean"],description:"Left-hand operand used when 'array' is not provided. Used with 'rightValue' and 'params.operator'."},rightValue:{type:["string","number","boolean"],description:"Right-hand operand used when 'array' is not provided. Used with 'leftValue' and 'params.operator'."}},additionalProperties:!1},params:{type:"object",properties:{operator:{type:"string",description:"The comparison operator to apply, such as '==', '!=', '>', '>=', '<', '<=', '||', '&&', or 'XOR'. Required if 'array' does not include the operator."},value:{type:"object",description:"An optional mapping for the comparison result. If provided, it must contain keys 'true' and/or 'false' to return custom values instead of booleans.",properties:{true:{type:["string","number","boolean"],description:"Custom result to return when the comparison evaluates to true."},false:{type:["string","number","boolean"],description:"Custom result to return when the comparison evaluates to false."}},additionalProperties:!1}},additionalProperties:!1},output:{},samples:[{inputs:{array:["abc","==","abc"]},params:{value:{true:"a",false:"b"}},result:{result:"a"}},{inputs:{array:["abc","==","abca"]},params:{value:{true:"a",false:"b"}},result:{result:"b"}},{inputs:{array:["abc","==","abc"]},params:{},result:{result:!0}},{inputs:{array:["abc","==","abcd"]},params:{},result:{result:!1}},{inputs:{array:["abc","!=","abc"]},params:{},result:{result:!1}},{inputs:{array:["abc","!=","abcd"]},params:{},result:{result:!0}},{inputs:{array:["10",">","5"]},params:{},result:{result:!0}},{inputs:{array:["10",">","15"]},params:{},result:{result:!1}},{inputs:{array:[10,">",5]},params:{},result:{result:!0}},{inputs:{array:[10,">",15]},params:{},result:{result:!1}},{inputs:{array:["10",">=","5"]},params:{},result:{result:!0}},{inputs:{array:["10",">=","10"]},params:{},result:{result:!0}},{inputs:{array:["10",">=","19"]},params:{},result:{result:!1}},{inputs:{array:[10,">=",5]},params:{},result:{result:!0}},{inputs:{array:[10,">=",10]},params:{},result:{result:!0}},{inputs:{array:[10,">=",19]},params:{},result:{result:!1}},{inputs:{array:["10","<","5"]},params:{},result:{result:!1}},{inputs:{array:["10","<","15"]},params:{},result:{result:!0}},{inputs:{array:[10,"<",5]},params:{},result:{result:!1}},{inputs:{array:[10,"<",15]},params:{},result:{result:!0}},{inputs:{array:["10","<=","5"]},params:{},result:{result:!1}},{inputs:{array:["10","<=","10"]},params:{},result:{result:!0}},{inputs:{array:["10","<=","19"]},params:{},result:{result:!0}},{inputs:{array:[10,"<=",5]},params:{},result:{result:!1}},{inputs:{array:[10,"<=",10]},params:{},result:{result:!0}},{inputs:{array:[10,"<=",19]},params:{},result:{result:!0}},{inputs:{array:[!0,"||",!1]},params:{},result:{result:!0}},{inputs:{array:[!1,"||",!1]},params:{},result:{result:!1}},{inputs:{array:[!0,"&&",!1]},params:{},result:{result:!1}},{inputs:{array:[!0,"&&",!0]},params:{},result:{result:!0}},{inputs:{array:[!0,"XOR",!1]},params:{},result:{result:!0}},{inputs:{array:[!1,"XOR",!0]},params:{},result:{result:!0}},{inputs:{array:[!1,"XOR",!1]},params:{},result:{result:!1}},{inputs:{array:[!0,"XOR",!0]},params:{},result:{result:!1}},{inputs:{array:[["aaa","==","aaa"],"||",["aaa","==","bbb"]]},params:{},result:{result:!0}},{inputs:{array:[["aaa","==","aaa"],"&&",["aaa","==","bbb"]]},params:{},result:{result:!1}},{inputs:{array:[[["aaa","==","aaa"],"&&",["bbb","==","bbb"]],"||",["aaa","&&","bbb"]]},params:{},result:{result:!0}},{inputs:{array:["abc","abc"]},params:{value:{true:"a",false:"b"},operator:"=="},result:{result:"a"}},{inputs:{array:["abc","abca"]},params:{value:{true:"a",false:"b"},operator:"=="},result:{result:"b"}},{inputs:{array:["abc","abc"]},params:{operator:"=="},result:{result:!0}},{inputs:{array:["abc","abcd"]},params:{operator:"=="},result:{result:!1}},{inputs:{array:["abc","abc"]},params:{operator:"!="},result:{result:!1}},{inputs:{array:["abc","abcd"]},params:{operator:"!="},result:{result:!0}},{inputs:{array:["10","5"]},params:{operator:">"},result:{result:!0}},{inputs:{array:["10","15"]},params:{operator:">"},result:{result:!1}},{inputs:{array:[10,5]},params:{operator:">"},result:{result:!0}},{inputs:{array:[10,15]},params:{operator:">"},result:{result:!1}},{inputs:{array:["10","5"]},params:{operator:">="},result:{result:!0}},{inputs:{array:["10","10"]},params:{operator:">="},result:{result:!0}},{inputs:{array:["10","19"]},params:{operator:">="},result:{result:!1}},{inputs:{array:[10,5]},params:{operator:">="},result:{result:!0}},{inputs:{array:[10,10]},params:{operator:">="},result:{result:!0}},{inputs:{array:[10,19]},params:{operator:">="},result:{result:!1}},{inputs:{array:["10","5"]},params:{operator:"<"},result:{result:!1}},{inputs:{array:["10","15"]},params:{operator:"<"},result:{result:!0}},{inputs:{array:[10,5]},params:{operator:"<"},result:{result:!1}},{inputs:{array:[10,15]},params:{operator:"<"},result:{result:!0}},{inputs:{array:[!0,!1]},params:{operator:"||"},result:{result:!0}},{inputs:{array:[!1,!1]},params:{operator:"||"},result:{result:!1}},{inputs:{array:[!0,!1]},params:{operator:"&&"},result:{result:!1}},{inputs:{array:[!0,!0]},params:{operator:"&&"},result:{result:!0}},{inputs:{array:[!0,!1]},params:{operator:"XOR"},result:{result:!0}},{inputs:{array:[!1,!0]},params:{operator:"XOR"},result:{result:!0}},{inputs:{array:[!1,!1]},params:{operator:"XOR"},result:{result:!1}},{inputs:{array:[!0,!0]},params:{operator:"XOR"},result:{result:!1}},{inputs:{leftValue:"abc",rightValue:"abc"},params:{value:{true:"a",false:"b"},operator:"=="},result:{result:"a"}},{inputs:{leftValue:"abc",rightValue:"abca"},params:{value:{true:"a",false:"b"},operator:"=="},result:{result:"b"}}],description:"compare",category:["compare"],author:"Receptron",repository:"https://github.com/receptron/graphai",source:"https://github.com/receptron/graphai/blob/main/agents/vanilla_agents/src/compare_agents/compare_agent.ts",package:"@graphai/vanilla",license:"MIT"},Re=async({namedInputs:t,params:a})=>{const{imageType:r,detail:s}=a,{array:o,prompt:p}=t;n("images2messageAgent",t),e(!!r,"images2messageAgent: params.imageType is UNDEFINED! Set Type: png, jpg...");const i=o.map((e=>{const t=((e,t,a)=>"http"===t?{url:e}:{url:`data:image/${t};base64,${e}`,detail:a??"auto"})(e,r,s);return{type:"image_url",image_url:t}}));return p&&i.unshift({type:"text",text:p}),{message:{role:"user",content:i}}},Oe={name:"images2messageAgent",agent:Re,mock:Re,inputs:{type:"object",properties:{array:{type:"array",description:"An array of base64-encoded image data strings or image URLs. These will be converted into OpenAI Vision-compatible image message format.",items:{type:"string",description:"Base64 image string or HTTP URL depending on 'imageType'."}},prompt:{type:"string",description:"Optional prompt text to include as the first message content before images."}},required:["array"],additionalProperties:!1},params:{type:"object",properties:{imageType:{type:"string",description:"The type of image input: 'png', 'jpg', etc. for base64, or 'http' for image URLs."},detail:{type:"string",description:"The level of image detail requested by the model (e.g., 'auto', 'low', 'high'). Optional."}},required:["imageType"],additionalProperties:!1},output:{type:"object",properties:{message:{type:"object",description:"OpenAI-compatible chat message including images and optional prompt text.",properties:{role:{type:"string",enum:["user"],description:"Message role, always 'user' for this agent."},content:{type:"array",description:"The array of message content elements, including optional text and one or more images.",items:{type:"object",oneOf:[{properties:{type:{type:"string",const:"text"},text:{type:"string",description:"Prompt message text."}},required:["type","text"],additionalProperties:!1},{properties:{type:{type:"string",const:"image_url"},image_url:{type:"object",properties:{url:{type:"string",description:"URL or data URL of the image."},detail:{type:"string",description:"Image detail level (e.g., 'high', 'low', 'auto'). Optional for base64."}},required:["url"],additionalProperties:!1}},required:["type","image_url"],additionalProperties:!1}]}}},required:["role","content"],additionalProperties:!1}},required:["message"],additionalProperties:!1},samples:[{inputs:{array:["abcabc","122123"]},params:{imageType:"png"},result:{message:{content:[{image_url:{detail:"auto",url:"data:image/png;base64,abcabc"},type:"image_url"},{image_url:{detail:"auto",url:"data:image/png;base64,122123"},type:"image_url"}],role:"user"}}},{inputs:{array:["abcabc","122123"],prompt:"hello"},params:{imageType:"jpg",detail:"high"},result:{message:{content:[{type:"text",text:"hello"},{image_url:{detail:"high",url:"data:image/jpg;base64,abcabc"},type:"image_url"},{image_url:{detail:"high",url:"data:image/jpg;base64,122123"},type:"image_url"}],role:"user"}}},{inputs:{array:["http://example.com/1.jpg","http://example.com/2.jpg"]},params:{imageType:"http"},result:{message:{content:[{image_url:{url:"http://example.com/1.jpg"},type:"image_url"},{image_url:{url:"http://example.com/2.jpg"},type:"image_url"}],role:"user"}}}],description:"Returns the message data for llm include image",category:["image"],author:"Receptron team",repository:"https://github.com/snakajima/graphai",source:"https://github.com/receptron/graphai/blob/main/agents/vanilla_agents/src/images_agents/image_to_message_agent.ts",package:"@graphai/vanilla",license:"MIT"},Ne=async({params:e,namedInputs:t,config:a})=>{const{array:r,item:s}=t,{apiKey:n,model:o,baseURL:p}={...a||{},...e},i=p??"https://api.openai.com/v1/embeddings",l=o??"text-embedding-3-small",u=n??process.env.OPENAI_API_KEY,m={"Content-Type":"application/json",Authorization:u?`Bearer ${u}`:""},c=r??[s],g=await fetch(i,{method:"POST",headers:m,body:JSON.stringify({input:c,model:l})}),d=await g.json();if(!g.ok)throw new Error(`HTTP error! status: ${g.status}`);return"data"in d?d.data.map((e=>e.embedding)):"embeddings"in d?d.embeddings:void 0},Me={name:"stringEmbeddingsAgent",agent:Ne,mock:Ne,samples:[],description:"Embeddings Agent",category:["embedding"],author:"Receptron team",repository:"https://github.com/receptron/graphai",source:"https://github.com/receptron/graphai/blob/main/agents/vanilla_agents/src/embedding_agent.ts",package:"@graphai/vanilla",cacheType:"pureAgent",license:"MIT"};export{C as arrayFlatAgent,U as arrayJoinAgent,$ as arrayToObjectAgent,Ee as compareAgent,P as consoleAgent,Q as copy2ArrayAgent,de as copyAgent,B as copyMessageAgent,X as countingAgent,ie as dataSumTemplateAgent,L as dotProductAgent,H as echoAgent,Oe as images2messageAgent,v as jsonParserAgent,be as lookupDictionaryAgent,se as mapAgent,ee as mergeNodeIdAgent,ve as mergeObjectAgent,I as nestedAgent,N as popAgent,ce as propertyFilterAgent,R as pushAgent,q as shiftAgent,ke as sleeperAgent,J as sortByValuesAgent,ae as streamMockAgent,A as stringCaseVariantsAgent,Me as stringEmbeddingsAgent,i as stringSplitterAgent,c as stringTemplateAgent,_ as stringUpdateTextAgent,oe as totalAgent,je as vanillaFetchAgent};
//# sourceMappingURL=bundle.esm.min.js.map
