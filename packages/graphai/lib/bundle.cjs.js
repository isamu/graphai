"use strict";var t;exports.NodeState=void 0,(t=exports.NodeState||(exports.NodeState={})).Waiting="waiting",t.Queued="queued",t.Executing="executing",t.ExecutingServer="executing-server",t.Failed="failed",t.TimedOut="timed-out",t.Abort="abort",t.Completed="completed",t.Injected="injected",t.Skipped="skipped";const e={debug:!0,info:!0,log:!0,warn:!0,error:!0};let s=null;function i(t,...i){e[t]&&(s?s(t,...i):(console[t]||console.log)(...i))}const n={setLevelEnabled:function(t,s){e[t]=s},setLogger:function(t){s=t},debug:function(...t){i("debug",...t)},info:function(...t){i("info",...t)},log:function(...t){i("log",...t)},warn:function(...t){i("warn",...t)},error:function(...t){i("error",...t)}},r=/^[a-zA-Z]+\([^)]*\)$/,o=[(t,e)=>{if(Array.isArray(t)){if("length()"===e)return t.length;if("flat()"===e)return t.flat();if("toJSON()"===e)return JSON.stringify(t,null,2);if("isEmpty()"===e)return 0===t.length;if("average()"===e||"mean()"===e)return t.length?t.reduce(((t,e)=>t+e),0)/t.length:0;if("sum()"===e)return t.reduce(((t,e)=>t+e),0);if("max()"===e)return t.length?Math.max(...t):0;if("min()"===e)return t.length?Math.min(...t):0;const s=e.match(/^join\(([,-\s]?)\)$/);if(s&&Array.isArray(s))return t.join(s[1]??"")}},(t,e)=>{if(d(t)){if("keys()"===e)return Object.keys(t);if("values()"===e)return Object.values(t);if("toJSON()"===e)return JSON.stringify(t,null,2)}},(t,e)=>{if("string"==typeof t){if("codeBlock()"===e){const e=("\n"+t).match(/\n```[a-zA-Z]*([\s\S]*?)\n```/);if(e)return e[1]}if("codeBlockOrRaw()"===e){const e=("\n"+t).match(/\n```[a-zA-Z]*([\s\S]*?)\n```/);return e?e[1]:t}if("jsonParse()"===e)return JSON.parse(t);if("toNumber()"===e){const e=Number(t);if(!isNaN(e))return e}if("trim()"===e)return t.trim();if("toLowerCase()"===e)return t.toLowerCase();if("toUpperCase()"===e)return t.toUpperCase();const s=e.match(/^equal\(([A-Za-z0-9!#$%&()*+,\-./:;<=>?@]+)\)/);if(s)return t===s[1];const i=e.match(/^slice\((-?\d+)(?:,\s*(-?\d+))?\)/);if(i){if(void 0!==i[2])return t.slice(Number(i[1]),Number(i[2]));if(void 0!==i[1])return t.slice(Number(i[1]));n.warn("slice is not valid format: "+i)}const r=e.match(/^split\(([-_:;.,\s\n]+)\)$/);if(r)return t.split(r[1])}},(t,e)=>{if(void 0!==t&&Number.isFinite(t)){if("toString()"===e)return String(t);const s=/^add\((-?\d+)\)$/,i=e.match(s);if(i)return Number(t)+Number(i[1]);const n=e.match(/^equal\(([A-Za-z0-9!#$%&()*+,\-/:;<=>?@]+)\)/);if(n)return t===Number(n[1])}},(t,e)=>{if("boolean"==typeof t&&"not()"===e)return!t},(t,e)=>{if(void 0===t){const t=e.match(/^default\(([A-Za-z0-9!#$%&()*+,\-/:;<=>?@]+)\)/);if(t)return t[1].match(/^[0-9-]+$/)?Number(t[1]):t[1]}}],a=(t,e)=>"@now"===t||"@now_ms"===t?Date.now():"@now_s"===t?Math.floor(Date.now()/1e3):"@loop"===t?e[S].result:(n.warn("not match template utility function: ${"+t+"}"),""),h=(t,e=!1,s)=>{if(e){if("string"==typeof t&&"."===t[0]){return{nodeId:"self",propIds:t.split(".").slice(1)}}return{value:t}}if("string"==typeof t){const e=/^:(.*)$/,i=t.match(e);if(i){const t=i[1].split(/(?<!\()\.(?!\))/);return 1==t.length?{nodeId:t[0]}:{nodeId:t[0],propIds:t.slice(1)}}const n=/^@(.*)$/,r=t.match(n);if(s&&r)return{value:a(t,s)}}return{value:t}};function u(t,e,s=!1){if(!t){if(!s)throw new Error(e);n.warn("warn: "+e)}}const d=t=>null!==t&&"object"==typeof t,c=t=>null==t,l="Intentional Error for Debugging",p={name:"defaultAgentInfo",samples:[{inputs:[],params:{},result:{}}],description:"",category:[],author:"",repository:"",license:""},g=t=>{const e=[];return Object.keys(t).forEach((s=>{e.push([s]),Object.keys(t[s]).length>0&&g(t[s]).forEach((t=>{e.push([s,...t])}))})),e},f=(t,e)=>g({[t]:y(e)}).map((t=>":"+t.join("."))),y=t=>null==t||"string"==typeof t?{}:Array.isArray(t)?Array.from(t.keys()).reduce(((e,s)=>(e["$"+String(s)]=y(t[s]),e)),{}):Object.keys(t).reduce(((e,s)=>(e[s]=y(t[s]),e)),{}),m=t=>!!(Array.isArray(t)?0!==t.length:t),I={debugInfo:{nodeId:"test",retry:0,verbose:!0,state:exports.NodeState.Executing,subGraphs:new Map},params:{},filterParams:{},agents:{},log:[]},b=t=>d(t)&&!Array.isArray(t)&&Object.keys(t||{}).length>0,w=t=>"agent"in t,N=t=>!("agent"in t),S="__loopIndex",v=t=>{if(Array.isArray(t))return t.map((t=>v(t))).flat();if(d(t))return Object.values(t).map((t=>v(t))).flat();if("string"==typeof t){const e=[...t.matchAll(/\${(:[^}]+)}/g)].map((t=>t[1]));if(e.length>0)return v(e)}return h(t)},k=t=>{if(!Array.isArray(t))throw new Error("sources must be array!! maybe inputs is invalid");return t.filter((t=>t.nodeId)).map((t=>t.nodeId))};class A{constructor(t){this.nodeId=t,this.state=exports.NodeState.Waiting}initForComputedNode(t,e){this.agentId=t.getAgentId(),this.params=t.params,e.appendLog(this)}onInjected(t,e,s){const i="endTime"in this;this.result=t.result,this.state=t.state,this.endTime=Date.now(),this.injectFrom=s,e.setLoopLog(this),i?e.updateLog(this):e.appendLog(this)}onComplete(t,e,s){this.result=t.result,this.resultKeys=f(this.agentId||"",t.result),this.state=t.state,this.endTime=Date.now(),e.setLoopLog(this),s.length>0&&(this.log=s),e.updateLog(this)}beforeExecute(t,e,s,i){this.state=t.state,this.retryCount=t.retryCount>0?t.retryCount:void 0,this.startTime=s,this.inputs=k(t.dataSources),this.inputsData=i.length>0?i:void 0,e.setLoopLog(this),e.appendLog(this)}beforeAddTask(t,e){this.state=t.state,e.setLoopLog(this),e.appendLog(this)}onError(t,e,s){this.state=t.state,this.errorMessage=s,this.endTime=Date.now(),e.setLoopLog(this),e.updateLog(this)}onSkipped(t,e){this.state=t.state,e.setLoopLog(this),e.updateLog(this)}}const x=(t,e,s)=>{if(e&&e.length>0){const i=((t,e,s)=>{if(e.match(r))for(const i of s){const s=i(t,e);if(!c(s))return s}if(Array.isArray(t)){const s=/^\$(\d+)$/,i=e.match(s);if(i)return t[parseInt(i[1],10)];if("$last"===e)return t[t.length-1]}else if(d(t)&&e in t)return t[e]})(t,e[0],s);return void 0===i&&n.error(`prop: ${e.join(".")} is not hit`),e.length>1?x(i,e.slice(1),s):i}return t},C=(t,e,s=[])=>e.nodeId?x(t,e.propIds,s):e.value,L=(t,e,s,i=!1)=>{if(Array.isArray(t))return t.map((t=>L(t,e,s,i)));if(b(t))return E(t,e,s,i);if("string"==typeof t){const n=[...t.matchAll(/\${([:@][^}]+)}/g)].map((t=>t[1]));if(n.length>0)return((t,e,s,i,n)=>{const r=L(e.filter((t=>t.startsWith(":"))),s,i,n),o=e.filter((t=>t.startsWith("@"))).reduce(((t,e)=>(t[e]=a(e,s),t)),{});return Array.from(e.keys()).reduce(((t,s)=>e[s].startsWith(":")?t.replaceAll("${"+e[s]+"}",r[s]):t.replaceAll("${"+e[s]+"}",o[e[s]])),t)})(t,n,e,s,i)}return O(h(t,i,e),e,s)},E=(t,e,s,i=!1)=>Object.keys(t).reduce(((n,r)=>{const o=t[r];return n[r]=b(o)?E(o,e,s,i):L(o,e,s,i),n}),{}),O=(t,e,s)=>{const{result:i}=t.nodeId?e[t.nodeId]:{result:void 0};return C(i,t,s)},j=t=>Array.isArray(t)?t.map((t=>j(t))).filter((t=>!c(t))):d(t)?Object.keys(t).reduce(((e,s)=>{const i=j(t[s]);return c(i)||(e[s]=i),e}),{}):t;class R{constructor(t,e){this.waitlist=new Set,this.state=exports.NodeState.Waiting,this.result=void 0,this.nodeId=t,this.graph=e,this.log=new A(t),this.console={}}asString(){return`${this.nodeId}: ${this.state} ${[...this.waitlist]}`}onSetResult(){this.waitlist.forEach((t=>{const e=this.graph.nodes[t];e.isComputedNode&&(e.removePending(this.nodeId),this.graph.pushQueueIfReadyAndRunning(e))}))}afterConsoleLog(t){!1!==this.console&&(!0===this.console||!0===this.console.after?n.log("string"==typeof t?t:JSON.stringify(t,null,2)):this.console.after&&(d(this.console.after)?n.log(JSON.stringify(E(this.console.after,{self:{result:t}},this.graph.propFunctions,!0),null,2)):n.log(this.console.after)))}}class T extends R{constructor(t,e,s,i){if(super(e,i),this.retryCount=0,this.dataSources=[],this.isSkip=!1,this.isStaticNode=!1,this.isComputedNode=!0,this.graphId=t,this.params=s.params??{},this.console=s.console??{},this.filterParams=s.filterParams??{},this.passThrough=s.passThrough,this.retryLimit=s.retry??i.retryLimit??0,this.repeatUntil=s.repeatUntil,this.timeout=s.timeout,this.isResult=s.isResult??!1,this.priority=s.priority??0,u(["function","string"].includes(typeof s.agent),"agent must be either string or function"),"string"==typeof s.agent)this.agentId=s.agent;else{const t=s.agent;this.agentFunction=async({namedInputs:e,params:s})=>t(e,s)}if(this.anyInput=s.anyInput??!1,this.inputs=s.inputs,this.output=s.output,this.dataSources=[...s.inputs?v(s.inputs).flat(10):[],...this.agentId?[h(this.agentId)]:[],...s.passThrough?v(s.passThrough).flat(10):[]],s.inputs&&Array.isArray(s.inputs))throw new Error(`array inputs have been deprecated. nodeId: ${e}: see https://github.com/receptron/graphai/blob/main/docs/NamedInputs.md`);this.pendings=new Set(k(this.dataSources)),s.graph&&(this.nestedGraph="string"==typeof s.graph?this.addPendingNode(s.graph):s.graph),s.graphLoader&&i.graphLoader&&(this.nestedGraph=i.graphLoader(s.graphLoader)),s.if&&(this.ifSource=this.addPendingNode(s.if)),s.unless&&(this.unlessSource=this.addPendingNode(s.unless)),s.defaultValue&&(this.defaultValue=s.defaultValue),this.isSkip=!1,this.log.initForComputedNode(this,i)}getAgentId(){return this.agentId??"__custom__function"}getConfig(t,e){if(e){if(t)return this.graph.config;const s=this.graph.config??{};return{...s.global??{},...s[e]??{}}}return{}}addPendingNode(t){const e=h(t);return u(!!e.nodeId,`Invalid data source ${t}`),this.pendings.add(e.nodeId),e}updateState(t){this.state=t,this.debugInfo&&(this.debugInfo.state=t)}resetPending(){this.pendings.clear(),this.state===exports.NodeState.Executing&&this.updateState(exports.NodeState.Abort),this.debugInfo&&this.debugInfo.subGraphs&&this.debugInfo.subGraphs.forEach((t=>t.abort(!0)))}isReadyNode(){return this.state===exports.NodeState.Waiting&&0===this.pendings.size&&(this.isSkip=!!(this.ifSource&&!m(this.graph.resultOf(this.ifSource))||this.unlessSource&&m(this.graph.resultOf(this.unlessSource))),!this.isSkip||void 0!==this.defaultValue||(this.updateState(exports.NodeState.Skipped),this.log.onSkipped(this,this.graph),!1))}retry(t,e){this.updateState(t),this.log.onError(this,this.graph,e.message),this.retryCount<this.retryLimit?(this.retryCount++,this.execute()):(this.result=void 0,this.error=e,this.transactionId=void 0,this.graph.onExecutionComplete(this))}checkDataAvailability(){return Object.values(this.graph.resultsOf(this.inputs)).flat().some((t=>void 0!==t))}beforeAddTask(){this.updateState(exports.NodeState.Queued),this.log.beforeAddTask(this,this.graph)}removePending(t){this.anyInput?this.checkDataAvailability()&&this.pendings.clear():this.pendings.delete(t)}isCurrentTransaction(t){return this.transactionId===t}executeTimeout(t){this.state===exports.NodeState.Executing&&this.isCurrentTransaction(t)&&(n.warn(`-- timeout ${this.timeout} with ${this.nodeId}`),this.retry(exports.NodeState.TimedOut,Error("Timeout")))}shouldApplyAgentFilter(t,e){return!!(t.agentIds&&Array.isArray(t.agentIds)&&t.agentIds.length>0&&e&&t.agentIds.includes(e))||(!!(t.nodeIds&&Array.isArray(t.nodeIds)&&t.nodeIds.length>0&&t.nodeIds.includes(this.nodeId))||!t.agentIds&&!t.nodeIds)}agentFilterHandler(t,e,s){let i=0;const n=t=>{const r=this.graph.agentFilters[i++];return r?this.shouldApplyAgentFilter(r,s)?(r.filterParams&&(t.filterParams={...r.filterParams,...t.filterParams}),r.agent(t,n)):n(t):e(t)};return n(t)}async execute(){if(this.isSkip)return void this.afterExecute(this.defaultValue,[]);const t=this.graph.resultsOf(this.inputs,this.anyInput),e=this.agentId?this.graph.resultOf(h(this.agentId)):this.agentId;"function"==typeof e&&(this.agentFunction=e);const s=Boolean(this.nestedGraph)||Boolean(e&&this.graph.getAgentFunctionInfo(e).hasGraphData),i=this.getConfig(s,e),r=Date.now();this.prepareExecute(r,Object.values(t)),this.timeout&&this.timeout>0&&setTimeout((()=>{this.executeTimeout(r)}),this.timeout);try{const o=this.agentFunction??this.graph.getAgentFunctionInfo(e).agent,a=[],h=this.getContext(t,a,e,i);s&&(this.graph.taskManager.prepareForNesting(),h.forNestedGraph={graphData:this.nestedGraph?"nodes"in this.nestedGraph?this.nestedGraph:this.graph.resultOf(this.nestedGraph):{version:0,nodes:{}},agents:this.graph.agentFunctionInfoDictionary,graphOptions:{agentFilters:this.graph.agentFilters,taskManager:this.graph.taskManager,bypassAgentIds:this.graph.bypassAgentIds,config:i,graphLoader:this.graph.graphLoader},onLogCallback:this.graph.onLogCallback,callbacks:this.graph.callbacks}),this.beforeConsoleLog(h);const u=await this.agentFilterHandler(h,o,e);if(this.afterConsoleLog(u),s&&this.graph.taskManager.restoreAfterNesting(),!this.isCurrentTransaction(r))return void n.log(`-- transactionId mismatch with ${this.nodeId} (probably timeout)`);if(this.repeatUntil?.exists){const t={self:{result:this.getResult(u)}},e=E({data:this.repeatUntil?.exists},t,[],!0);if(c(e?.data))return void this.retry(exports.NodeState.Failed,Error("Repeat Until"))}this.afterExecute(u,a)}catch(e){this.errorProcess(e,r,t)}}afterExecute(t,e){this.state!=exports.NodeState.Abort&&(this.updateState(exports.NodeState.Completed),this.result=this.getResult(t),this.output&&(this.result=E(this.output,{self:this},this.graph.propFunctions,!0),this.passThrough&&(this.result={...this.result,...this.graph.resultsOf(this.passThrough)})),this.log.onComplete(this,this.graph,e),this.onSetResult(),this.graph.onExecutionComplete(this))}prepareExecute(t,e){this.updateState(exports.NodeState.Executing),this.log.beforeExecute(this,this.graph,t,e),this.transactionId=t}errorProcess(t,e,s){t instanceof Error&&t.message!==l&&(n.error(`<-- NodeId: ${this.nodeId}, Agent: ${this.agentId}`),n.error({namedInputs:s}),n.error(t),n.error("--\x3e")),this.isCurrentTransaction(e)?t instanceof Error?this.retry(exports.NodeState.Failed,t):(n.error(`-- NodeId: ${this.nodeId}: Unknown error was caught`),this.retry(exports.NodeState.Failed,Error("Unknown"))):n.warn(`-- transactionId mismatch with ${this.nodeId} (not timeout)`)}getContext(t,e,s,i){this.debugInfo=this.getDebugInfo(s);return{params:{...this.params??{},...b(t?.params)?t?.params:{}},namedInputs:t,inputSchema:this.agentFunction?void 0:this.graph.getAgentFunctionInfo(s)?.inputs,debugInfo:this.debugInfo,cacheType:this.agentFunction?void 0:this.graph.getAgentFunctionInfo(s)?.cacheType,filterParams:this.filterParams,config:i,log:e}}getResult(t){if(t&&this.passThrough){if(d(t)&&!Array.isArray(t))return{...t,...this.graph.resultsOf(this.passThrough)};if(Array.isArray(t))return t.map((t=>d(t)&&!Array.isArray(t)?{...t,...this.graph.resultsOf(this.passThrough)}:t))}return t}getDebugInfo(t){return{nodeId:this.nodeId,agentId:t,retry:this.retryCount,state:this.state,subGraphs:new Map,verbose:this.graph.verbose,version:this.graph.version,isResult:this.isResult}}beforeConsoleLog(t){!1!==this.console&&(!0===this.console||!0===this.console.before?n.log(JSON.stringify(t.namedInputs,null,2)):this.console.before&&n.log(this.console.before))}}class $ extends R{constructor(t,e,s){super(t,s),this.isStaticNode=!0,this.isComputedNode=!1,this.value=e.value,this.update=e.update?h(e.update):void 0,this.isResult=e.isResult??!1,this.console=e.console??{}}updateValue(t,e){this.value=t,this.log.onInjected(this,this.graph,e)}setResultValue(t){this.state=exports.NodeState.Injected,this.result=this.value,this.log.onInjected(this,this.graph,t),this.onSetResult()}consoleLog(){this.afterConsoleLog(this.result)}}const F=["nodes","concurrency","agentId","loop","verbose","version","metadata"],D=["inputs","output","anyInput","params","retry","repeatUntil","timeout","agent","graph","graphLoader","isResult","priority","if","unless","defaultValue","filterParams","console","passThrough"],P=["value","update","isResult","console"];class G extends Error{constructor(t){super(`[41m${t}[0m`),Object.setPrototypeOf(this,G.prototype)}}const M=(t,e)=>{(t=>{if(void 0===t.nodes)throw new G("Invalid Graph Data: no nodes");if("object"!=typeof t.nodes)throw new G("Invalid Graph Data: invalid nodes");if(Array.isArray(t.nodes))throw new G("Invalid Graph Data: nodes must be object");if(0===Object.keys(t.nodes).length)throw new G("Invalid Graph Data: nodes is empty");Object.keys(t).forEach((t=>{if(!F.includes(t))throw new G("Graph Data does not allow "+t)}))})(t),(t=>{if(t.loop){if(void 0===t.loop.count&&void 0===t.loop.while)throw new G("Loop: Either count or while is required in loop");if(void 0!==t.loop.count&&void 0!==t.loop.while)throw new G("Loop: Both count and while cannot be set")}if(void 0!==t.concurrency){if(!Number.isInteger(t.concurrency))throw new G("Concurrency must be an integer");if(t.concurrency<1)throw new G("Concurrency must be a positive integer")}})(t);const s=[],i=[],n=new Set;return Object.keys(t.nodes).forEach((e=>{const r=t.nodes[e],o=N(r);(t=>{if(t.agent&&t.value)throw new G("Cannot set both agent and value")})(r);const a=o?"":r.agent;var h;o&&(h=r,Object.keys(h).forEach((t=>{if(!P.includes(t))throw new G("Static node does not allow "+t)})),1)&&i.push(e),!o&&(t=>(Object.keys(t).forEach((t=>{if(!D.includes(t))throw new G("Computed node does not allow "+t)})),!0))(r)&&s.push(e)&&"string"==typeof a&&n.add(a)})),((t,e)=>{t.forEach((t=>{if(!e.has(t)&&":"!==t[0])throw new G("Invalid Agent : "+t+" is not in AgentFunctionInfoDictionary.")}))})(n,new Set(e)),((t,e,s)=>{const i=new Set(Object.keys(t.nodes)),n={},r={};s.forEach((e=>{const s=t.nodes[e];n[e]=new Set;const o=(t,s)=>{s.forEach((s=>{if(s){if(!i.has(s))throw new G(`${t} not match: NodeId ${e}, Inputs: ${s}`);void 0===r[s]&&(r[s]=new Set),n[e].add(s),r[s].add(e)}}))};s&&w(s)&&(s.inputs&&o("Inputs",k(v(s.inputs))),s.if&&o("If",k(v({if:s.if}))),s.unless&&o("Unless",k(v({unless:s.unless}))),s.graph&&"string"==typeof s?.graph&&o("Graph",k(v({graph:s.graph}))),"string"==typeof s.agent&&":"===s.agent[0]&&o("Agent",k(v({agent:s.agent}))))})),e.forEach((e=>{const s=t.nodes[e];if(N(s)&&s.update){const t=s.update,n=h(t).nodeId;if(!n)throw new G("Update it a literal");if(!i.has(n))throw new G(`Update not match: NodeId ${e}, update: ${t}`)}}));const o=t=>{t.forEach((t=>{(r[t]||[]).forEach((e=>{n[e].delete(t)}))}));const e=[];return Object.keys(n).forEach((t=>{0===n[t].size&&(e.push(t),delete n[t])})),e};let a=o(e);if(0===a.length)throw new G("No Initial Runnning Node");do{a=o(a)}while(a.length>0);if(Object.keys(n).length>0)throw new G("Some nodes are not executed: "+Object.keys(n).join(", "))})(t,i,s),!0};class Q{constructor(t){this.taskQueue=[],this.runningNodes=new Set,this.concurrency=t}dequeueTaskIfPossible(){if(this.runningNodes.size<this.concurrency){const t=this.taskQueue.shift();t&&(this.runningNodes.add(t.node),t.callback(t.node))}}addTask(t,e,s){const i=this.taskQueue.filter((e=>e.node.priority>=t.priority)).length;u(i<=this.taskQueue.length,"TaskManager.addTask: Something is really wrong."),this.taskQueue.splice(i,0,{node:t,graphId:e,callback:s}),this.dequeueTaskIfPossible()}isRunning(t){return[...this.runningNodes].filter((e=>e.graphId==t)).length>0||Array.from(this.taskQueue).filter((e=>e.graphId===t)).length>0}onComplete(t){u(this.runningNodes.has(t),`TaskManager.onComplete node(${t.nodeId}) is not in list`),this.runningNodes.delete(t),this.dequeueTaskIfPossible()}prepareForNesting(){this.concurrency++}restoreAfterNesting(){this.concurrency--}getStatus(t=!1){const e=Array.from(this.runningNodes).map((t=>t.nodeId)),s=this.taskQueue.map((t=>t.node.nodeId)),i=t?{runningNodes:e,queuedNodes:s}:{};return{concurrency:this.concurrency,queue:this.taskQueue.length,running:this.runningNodes.size,...i}}reset(){this.taskQueue.length=0,this.runningNodes.clear()}}const V=.5;exports.GraphAI=class{createNodes(t){const e=Object.keys(t.nodes).reduce(((e,s)=>{const i=t.nodes[s];if(w(i))e[s]=new T(this.graphId,s,i,this);else{const t=this.staticNodeInitData[s];e[s]=new $(s,void 0!==t?{...i,value:t}:i,this)}return e}),{});return Object.keys(e).forEach((t=>{const s=e[t];s.isComputedNode&&s.pendings.forEach((s=>{if(!e[s])throw new Error(`createNode: invalid input ${s} for node, ${t}`);e[s].waitlist.add(t)}))})),e}getValueFromResults(t,e){return C(t.nodeId?e[t.nodeId]:void 0,t,this.propFunctions)}setStaticNodeResults(t=!1){Object.keys(this.graphData.nodes).forEach((e=>{const s=this.nodes[e];if(s?.isStaticNode){const i=s?.value;void 0!==i&&s.setResultValue(e),t&&s.consoleLog()}}))}updateStaticNodes(t,e=!1){Object.keys(this.graphData.nodes).forEach((s=>{const i=this.nodes[s];if(i?.isStaticNode){const n=i?.update;if(n&&t){const e=this.getValueFromResults(n,t);this.updateStaticNodeValue(s,e,n.nodeId)}e&&i.consoleLog()}}))}constructor(t,e,s={taskManager:void 0,agentFilters:[],bypassAgentIds:[],config:{},graphLoader:void 0,forceLoop:!1}){this.staticNodeInitData={},this.logs=[],this.config={},this.onLogCallback=(t,e)=>{},this.callbacks=[],this.repeatCount=0,t.version||s.taskManager||n.warn("------------ missing version number"),this.version=t.version??V,this.version<V&&n.warn("------------ upgrade to 0.5!"),this.retryLimit=t.retry,this.graphId=`${Date.now().toString(36)}-${Math.random().toString(36).substr(2,9)}`,this.agentFunctionInfoDictionary=e,this.propFunctions=o,this.taskManager=s.taskManager??new Q(t.concurrency??8),this.agentFilters=s.agentFilters??[],this.bypassAgentIds=s.bypassAgentIds??[],this.config=s.config,this.graphLoader=s.graphLoader,this.forceLoop=s.forceLoop??!1,this.loop=t.loop,this.verbose=!0===t.verbose,this.onComplete=t=>{throw new Error("SOMETHING IS WRONG: onComplete is called without run()")},M(t,[...Object.keys(e),...this.bypassAgentIds]),(t=>{Object.keys(t).forEach((e=>{if("default"!==e){const s=t[e];if(!s||!s.agent)throw new G("No Agent: "+e+" is not in AgentFunctionInfoDictionary.")}}))})(e),this.graphData={...t,nodes:{...t.nodes,[S]:{value:0,update:`:${S}.add(1)`}}},this.nodes=this.createNodes(this.graphData)}getAgentFunctionInfo(t){if(t&&this.agentFunctionInfoDictionary[t])return this.agentFunctionInfoDictionary[t];if(t&&this.bypassAgentIds.includes(t))return{agent:async()=>null,hasGraphData:!1,inputs:null,cacheType:void 0};throw new Error("No agent: "+t)}asString(){return Object.values(this.nodes).map((t=>t.asString())).join("\n")}results(t,e=!1){return Object.keys(this.nodes).filter((s=>t&&(e||s!==S)||this.nodes[s].isResult)).reduce(((t,e)=>{const s=this.nodes[e];return void 0!==s.result&&(t[e]=s.result),t}),{})}errors(){return Object.keys(this.nodes).reduce(((t,e)=>{const s=this.nodes[e];return s.isComputedNode&&void 0!==s.error&&(t[e]=s.error),t}),{})}pushReadyNodesIntoQueue(){Object.keys(this.nodes).forEach((t=>{const e=this.nodes[t];e.isComputedNode&&this.pushQueueIfReady(e)}))}pushQueueIfReady(t){t.isReadyNode()&&this.pushQueue(t)}pushQueueIfReadyAndRunning(t){this.isRunning()&&this.pushQueueIfReady(t)}pushQueue(t){t.beforeAddTask(),this.taskManager.addTask(t,this.graphId,(e=>{u(t.nodeId===e.nodeId,"GraphAI.pushQueue node mismatch"),t.execute()}))}async run(t=!1){this.setStaticNodeResults();const e=Object.values(this.nodes).filter((t=>t.isStaticNode)).filter((t=>void 0===t.result&&void 0===t.update));if(e.length>0){const t=e.map((t=>t.nodeId)).join(", ");throw new Error(`Static node(s) must have value. Set value, injectValue, or set update. Affected nodeIds: ${t}`)}if(this.isRunning())throw new Error("This GraphAI instance is already running");return this.pushReadyNodesIntoQueue(),this.isRunning()?new Promise(((e,s)=>{this.onComplete=(i=!1)=>{const n=this.errors(),r=Object.keys(n);r.length>0||i?s(n[r[0]]):e(this.results(t))}})):(n.warn("-- nothing to execute"),{})}abort(t=!1){this.isRunning()&&this.resetPending(),Object.values(this.nodes).forEach((t=>t.isComputedNode&&(t.transactionId=void 0))),t||this.taskManager.reset(),this.onComplete(this.isRunning())}resetPending(){Object.values(this.nodes).map((t=>{t.isComputedNode&&t.resetPending()}))}isRunning(){return this.taskManager.isRunning(this.graphId)}onExecutionComplete(t){this.taskManager.onComplete(t),this.isRunning()||this.processLoopIfNecessary()||this.onComplete(!1)}processLoopIfNecessary(){if(!this.forceLoop&&Object.keys(this.errors()).length>0)return!1;this.repeatCount++;const t=this.loop;if(!t)return!1;const e=this.results(!0,!0);if(this.updateStaticNodes(e),this.setStaticNodeResults(),void 0===t.count||this.repeatCount<t.count){if(t.while){const e=h(t.while),s=this.getValueFromResults(e,this.results(!0,!0));if(!m(s))return!1}return this.nodes=this.createNodes(this.graphData),this.updateStaticNodes(e,!0),this.setStaticNodeResults(),this.pushReadyNodesIntoQueue(),!0}return!1}initializeGraphAI(){if(this.isRunning())throw new Error("This GraphAI instance is running");this.nodes=this.createNodes(this.graphData),this.setStaticNodeResults()}setPreviousResults(t){this.updateStaticNodes(t)}setLoopLog(t){t.isLoop=!!this.loop,t.repeatCount=this.repeatCount}appendLog(t){this.logs.push(t),this.onLogCallback(t,!1),this.callbacks.forEach((e=>e(t,!1)))}updateLog(t){this.onLogCallback(t,!0),this.callbacks.forEach((e=>e(t,!1)))}registerCallback(t){this.callbacks.push(t)}clearCallbacks(){this.callbacks=[]}transactionLogs(){return this.logs}injectValue(t,e,s){this.staticNodeInitData[t]=e,this.updateStaticNodeValue(t,e,s)}setLoopCount(t){this.loop={count:t}}updateStaticNodeValue(t,e,s){const i=this.nodes[t];if(!i||!i.isStaticNode)throw new Error(`injectValue with Invalid nodeId, ${t}`);i.updateValue(e,s)}resultsOf(t,e=!1){const s=E(t??{},this.nodes,this.propFunctions);return e?(t=>Object.keys(t).reduce(((e,s)=>{const i=j(t[s]);return c(i)||(e[s]=i),e}),{}))(s):s}resultOf(t){return O(t,this.nodes,this.propFunctions)}},exports.GraphAILogger=n,exports.TaskManager=Q,exports.ValidationError=G,exports.agentInfoWrapper=t=>({agent:t,mock:t,...p}),exports.assert=u,exports.debugResultKey=f,exports.defaultAgentInfo=p,exports.defaultConcurrency=8,exports.defaultTestContext=I,exports.graphDataLatestVersion=V,exports.inputs2dataSources=v,exports.isComputedNodeData=w,exports.isNull=c,exports.isObject=d,exports.isStaticNodeData=N,exports.parseNodeName=h,exports.sleep=async t=>await new Promise((e=>setTimeout(e,t))),exports.strIntentionalError=l;
//# sourceMappingURL=bundle.cjs.js.map
