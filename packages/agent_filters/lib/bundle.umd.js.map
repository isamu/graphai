{"version":3,"file":"bundle.umd.js","sources":["../src/filters/http_client.ts"],"sourcesContent":["import { AgentFilterFunction, AgentFunctionContext, isObject } from \"graphai\";\n\nasync function* streamChatCompletion(url: string, postData: AgentFunctionContext, userHeaders: any) {\n  const { params, namedInputs, debugInfo, filterParams } = postData;\n  const postBody = { params, debugInfo, filterParams, namedInputs };\n  const headers = { ...userHeaders, \"Content-Type\": \"text/event-stream\" };\n\n  const completion = await fetch(url, {\n    headers,\n    method: \"POST\",\n    body: JSON.stringify(postBody),\n  });\n\n  const reader = completion.body?.getReader();\n\n  if (completion.status !== 200 || !reader) {\n    throw new Error(\"Request failed\");\n  }\n\n  const decoder = new TextDecoder(\"utf-8\");\n  let done = false;\n  while (!done) {\n    const { done: readDone, value } = await reader.read();\n    if (readDone) {\n      done = readDone;\n      reader.releaseLock();\n    } else {\n      const token = decoder.decode(value, { stream: true });\n      yield token;\n    }\n  }\n}\n\nconst streamingRequest = async (context: AgentFunctionContext, url: string, postData: AgentFunctionContext, userHeaders: any, isDebug: boolean | undefined) => {\n  const generator = streamChatCompletion(url, postData, userHeaders);\n\n  const messages = [];\n  for await (const token of generator) {\n    if (isDebug) {\n      console.log(token);\n    }\n    // callback to stream filter\n    if (token) {\n      messages.push(token);\n      if (messages.join(\"\").indexOf(\"___END___\") === -1 && context.filterParams.streamTokenCallback) {\n        context.filterParams.streamTokenCallback(token);\n      }\n    }\n  }\n\n  const payload_data = messages.join(\"\").split(\"___END___\")[1];\n  const data = JSON.parse(payload_data);\n  return data;\n};\nconst httpRequest = async (url: string, postData: AgentFunctionContext, userHeaders: any) => {\n  const headers = { ...userHeaders, \"Content-Type\": \"application/json\" };\n  const response = await fetch(url, {\n    method: \"post\",\n    headers,\n    body: JSON.stringify(postData),\n  });\n  return await response.json();\n};\n\nexport const httpAgentFilter: AgentFilterFunction = async (context, next) => {\n  const { params, debugInfo, filterParams, namedInputs, config } = context;\n\n  if (filterParams?.server) {\n    const { baseUrl, isDebug, serverAgentUrlDictionary } = filterParams.server;\n    const headers = config?.headers ?? {};\n    if (!isObject(headers)) {\n      throw new Error(\"httpAgentFilter: headers is not object.\");\n    }\n    const agentId = debugInfo.agentId;\n    const isStreaming = filterParams.streamTokenCallback !== undefined;\n    const url = serverAgentUrlDictionary && agentId && serverAgentUrlDictionary[agentId] ? serverAgentUrlDictionary[agentId] : [baseUrl, agentId].join(\"/\");\n    if (url === undefined) {\n      console.log(\"httpAgentFilter: Url is not defined\");\n    }\n    const postData = {\n      params,\n      debugInfo,\n      filterParams,\n      namedInputs,\n      inputs: namedInputs, // alias.\n    };\n    if (isStreaming) {\n      return await streamingRequest(context, url, postData, headers, isDebug);\n    }\n    return await httpRequest(url, postData, headers);\n  }\n  return next(context);\n};\n"],"names":["streamingRequest","async","context","url","postData","userHeaders","isDebug","generator","params","namedInputs","debugInfo","filterParams","postBody","headers","completion","fetch","method","body","JSON","stringify","reader","getReader","status","Error","decoder","TextDecoder","done","readDone","value","read","releaseLock","token","decode","stream","streamChatCompletion","messages","console","log","push","join","indexOf","streamTokenCallback","payload_data","split","parse","next","config","server","baseUrl","serverAgentUrlDictionary","isObject","agentId","isStreaming","undefined","inputs","response","json","httpRequest"],"mappings":"ozBAiCA,MAAMA,EAAmBC,MAAOC,EAA+BC,EAAaC,EAAgCC,EAAkBC,KAC5H,MAAMC,EAhCRN,gBAAqCE,EAAaC,EAAgCC,GAChF,MAAMG,OAAEA,EAAMC,YAAEA,EAAWC,UAAEA,EAASC,aAAEA,GAAiBP,EACnDQ,EAAW,CAAEJ,SAAQE,YAAWC,eAAcF,eAC9CI,EAAU,IAAKR,EAAa,eAAgB,qBAE5CS,QAAmBC,MAAMZ,EAAK,CAClCU,UACAG,OAAQ,OACRC,KAAMC,KAAKC,UAAUP,KAGjBQ,EAASN,EAAWG,MAAMI,YAEhC,GAA0B,MAAtBP,EAAWQ,SAAmBF,EAChC,MAAM,IAAIG,MAAM,kBAGlB,MAAMC,EAAU,IAAIC,YAAY,SAChC,IAAIC,GAAO,EACX,MAAQA,GAAM,CACZ,MAAQA,KAAMC,EAAQC,MAAEA,SAAgBR,EAAOS,OAC/C,GAAIF,EACFD,EAAOC,EACPP,EAAOU,kBACF,CACL,MAAMC,EAAQP,EAAQQ,OAAOJ,EAAO,CAAEK,QAAQ,UACxCF,GAGZ,CAGoBG,CAAqB/B,EAAKC,EAAUC,GAEhD8B,EAAW,GACjB,UAAW,MAAMJ,KAASxB,EACpBD,GACF8B,QAAQC,IAAIN,GAGVA,IACFI,EAASG,KAAKP,QACVI,EAASI,KAAK,IAAIC,QAAQ,cAAuBtC,EAAQS,aAAa8B,qBACxEvC,EAAQS,aAAa8B,oBAAoBV,IAK/C,MAAMW,EAAeP,EAASI,KAAK,IAAII,MAAM,aAAa,GAE1D,OADazB,KAAK0B,MAAMF,EACb,s5BAYuCzC,MAAOC,EAAS2C,KAClE,MAAMrC,OAAEA,EAAME,UAAEA,EAASC,aAAEA,EAAYF,YAAEA,EAAWqC,OAAEA,GAAW5C,EAEjE,GAAIS,GAAcoC,OAAQ,CACxB,MAAMC,QAAEA,EAAO1C,QAAEA,EAAO2C,yBAAEA,GAA6BtC,EAAaoC,OAC9DlC,EAAUiC,GAAQjC,SAAW,CAAE,EACrC,IAAKqC,EAAAA,SAASrC,GACZ,MAAM,IAAIU,MAAM,2CAElB,MAAM4B,EAAUzC,EAAUyC,QACpBC,OAAmDC,IAArC1C,EAAa8B,oBAC3BtC,EAAM8C,GAA4BE,GAAWF,EAAyBE,GAAWF,EAAyBE,GAAW,CAACH,EAASG,GAASZ,KAAK,UACvIc,IAARlD,GACFiC,QAAQC,IAAI,uCAEd,MAAMjC,EAAW,CACfI,SACAE,YACAC,eACAF,cACA6C,OAAQ7C,GAEV,OAAI2C,QACWpD,EAAiBE,EAASC,EAAKC,EAAUS,EAASP,QAjCjDL,OAAOE,EAAaC,EAAgCC,KACtE,MAAMQ,EAAU,IAAKR,EAAa,eAAgB,oBAC5CkD,QAAiBxC,MAAMZ,EAAK,CAChCa,OAAQ,OACRH,UACAI,KAAMC,KAAKC,UAAUf,KAEvB,aAAamD,EAASC,MAAM,EA4BbC,CAAYtD,EAAKC,EAAUS,GAE1C,OAAOgC,EAAK3C,EAAQ"}